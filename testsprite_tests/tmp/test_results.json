[
  {
    "projectId": "d3f9883c-1816-4052-bf75-e4e8e200692e",
    "testId": "9757585e-e4b8-461f-9e8d-052e3c56f494",
    "userId": "344844a8-1021-7022-adb9-65ed4dd64f25",
    "title": "TC001-patient_appointment_scheduling_api",
    "description": "Test the appointment scheduling API endpoint to ensure patients can successfully book appointments with all required details including visit type, consult type, practice type, and health insurance selection. Validate input data, check for correct creation of patient records and appointments, and verify generation of cancellation tokens.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\nimport datetime\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nAUTH = HTTPBasicAuth(\"maxim.degtiarev.dev@gmail.com\", \"admin1234\")\nTIMEOUT = 30\n\ndef test_patient_appointment_scheduling_api():\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\"\n    }\n\n    # Step 1: Retrieve required options for visit types, consult types, practice types, health insurance\n    # Assuming these endpoints exist according to PRD files\n\n    # Get visit types\n    visit_types_resp = requests.get(f\"{BASE_URL}/api/visit-types\", auth=AUTH, headers=headers, timeout=TIMEOUT)\n    assert visit_types_resp.status_code == 200, f\"Failed to get visit types: {visit_types_resp.text}\"\n    visit_types = visit_types_resp.json()\n    assert isinstance(visit_types, list) and len(visit_types) > 0, \"Visit types list is empty\"\n\n    # Get consult types\n    consult_types_resp = requests.get(f\"{BASE_URL}/api/consult-types\", auth=AUTH, headers=headers, timeout=TIMEOUT)\n    assert consult_types_resp.status_code == 200, f\"Failed to get consult types: {consult_types_resp.text}\"\n    consult_types = consult_types_resp.json()\n    assert isinstance(consult_types, list) and len(consult_types) > 0, \"Consult types list is empty\"\n\n    # Get health insurances\n    health_insurances_resp = requests.get(f\"{BASE_URL}/api/health-insurance\", auth=AUTH, headers=headers, timeout=TIMEOUT)\n    assert health_insurances_resp.status_code == 200, f\"Failed to get health insurance options: {health_insurances_resp.text}\"\n    health_insurances = health_insurances_resp.json()\n    assert isinstance(health_insurances, list) and len(health_insurances) > 0, \"Health insurance list is empty\"\n\n    # Select valid ids from options for payload\n    visit_type_id = visit_types[0]['id'] if 'id' in visit_types[0] else visit_types[0]\n    consult_type_id = consult_types[0]['id'] if 'id' in consult_types[0] else consult_types[0]\n    health_insurance_id = health_insurances[0]['id'] if 'id' in health_insurances[0] else health_insurances[0]\n\n    # To select a valid practice type, infer from available data or reuse visit_type (assuming practice types are part of consult/practice)\n    # Since there's no explicit endpoint for practice types in PRD filenames, we'll assume a static example or that it's part of visit type or consult type.\n    # Using a placeholder practice_type string:\n    practice_type = \"Consulta\"  # example value, adjust if needed\n\n    # Generate a valid appointment date: at least tomorrow, not weekend, within 30 days range, excluding holidays (simplified here)\n    def get_valid_appointment_date():\n        today = datetime.date.today()\n        for delta in range(1, 31):\n            candidate = today + datetime.timedelta(days=delta)\n            if candidate.weekday() < 5:  # Monday=0, Sunday=6 (exclude weekends)\n                return candidate.isoformat()\n        raise RuntimeError(\"No valid appointment date found in next 30 days excluding weekends\")\n\n    appointment_date = get_valid_appointment_date()\n\n    # Retrieve available time slots for that appointment date\n    available_times_resp = requests.get(f\"{BASE_URL}/api/available-times/{appointment_date}\", auth=AUTH, headers=headers, timeout=TIMEOUT)\n    assert available_times_resp.status_code == 200, f\"Failed to get available times: {available_times_resp.text}\"\n    available_times = available_times_resp.json()\n    assert isinstance(available_times, list) and len(available_times) > 0, \"No available time slots for the selected date\"\n    appointment_time = available_times[0]\n\n    # Prepare patient information\n    unique_identifier = str(uuid.uuid4())[:8]\n    patient_data = {\n        \"firstName\": \"Test\",\n        \"lastName\": f\"User{unique_identifier}\",\n        \"phone\": \"+541112345678\",  # Valid phone format as example\n        \"email\": f\"test.user{unique_identifier}@example.com\",\n        \"birthDate\": \"1980-01-01\"\n    }\n\n    # Create or confirm patient record - check if patient exists might be by phone or email (assuming POST /api/patients creates new patient)\n    patient_create_resp = requests.post(f\"{BASE_URL}/api/patients\", json=patient_data, auth=AUTH, headers=headers, timeout=TIMEOUT)\n    assert patient_create_resp.status_code in (200,201), f\"Failed to create patient: {patient_create_resp.text}\"\n    patient = patient_create_resp.json()\n    assert \"id\" in patient, \"Patient ID missing in response\"\n    patient_id = patient[\"id\"]\n\n    # Construct appointment payload based on PRD and form requirements\n    appointment_payload = {\n        \"patientId\": patient_id,\n        \"date\": appointment_date,\n        \"time\": appointment_time,\n        \"visitType\": visit_type_id,\n        \"consultType\": consult_type_id,\n        \"practiceType\": practice_type,\n        \"healthInsuranceId\": health_insurance_id,\n        # Additional required fields assumed minimal here (could be symptoms, notes...)\n    }\n\n    # Create appointment\n    appointment_create_resp = requests.post(f\"{BASE_URL}/api/appointments/create\", json=appointment_payload, auth=AUTH, headers=headers, timeout=TIMEOUT)\n    assert appointment_create_resp.status_code in (200,201), f\"Failed to create appointment: {appointment_create_resp.text}\"\n    appointment = appointment_create_resp.json()\n    assert \"id\" in appointment, \"Appointment ID missing in response\"\n    appointment_id = appointment[\"id\"]\n    assert \"cancellationToken\" in appointment, \"Cancellation token missing in appointment creation response\"\n    cancellation_token = appointment[\"cancellationToken\"]\n    assert isinstance(cancellation_token, str) and len(cancellation_token) > 0, \"Invalid cancellation token\"\n\n    # Optionally, fetch appointment to verify details saved correctly\n    get_appointment_resp = requests.get(f\"{BASE_URL}/api/appointments/{appointment_id}\", auth=AUTH, headers=headers, timeout=TIMEOUT)\n    assert get_appointment_resp.status_code == 200, f\"Failed to fetch appointment details: {get_appointment_resp.text}\"\n    appointment_details = get_appointment_resp.json()\n    assert appointment_details[\"id\"] == appointment_id\n    assert appointment_details[\"patientId\"] == patient_id\n    assert appointment_details[\"date\"] == appointment_date\n    assert appointment_details[\"time\"] == appointment_time\n    assert appointment_details[\"visitType\"] == visit_type_id\n    assert appointment_details[\"consultType\"] == consult_type_id\n    assert appointment_details[\"practiceType\"] == practice_type\n    assert appointment_details[\"healthInsuranceId\"] == health_insurance_id\n    assert \"cancellationToken\" in appointment_details and appointment_details[\"cancellationToken\"] == cancellation_token\n\n    # Cleanup: delete created appointment and patient\n    try:\n        pass  # test assertions passed\n    finally:\n        # Delete appointment\n        del_appointment_resp = requests.delete(f\"{BASE_URL}/api/appointments/{appointment_id}\", auth=AUTH, headers=headers, timeout=TIMEOUT)\n        assert del_appointment_resp.status_code in (200,204), f\"Failed to delete appointment: {del_appointment_resp.text}\"\n        # Delete patient\n        del_patient_resp = requests.delete(f\"{BASE_URL}/api/patients/{patient_id}\", auth=AUTH, headers=headers, timeout=TIMEOUT)\n        assert del_patient_resp.status_code in (200,204), f\"Failed to delete patient: {del_patient_resp.text}\"\n\ntest_patient_appointment_scheduling_api()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 129, in <module>\n  File \"<string>\", line 23, in test_patient_appointment_scheduling_api\nAssertionError: Visit types list is empty\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-19T17:33:30.267Z",
    "modified": "2026-01-19T17:34:42.928Z"
  },
  {
    "projectId": "d3f9883c-1816-4052-bf75-e4e8e200692e",
    "testId": "62279f20-b2dd-49d5-9629-4021ae14a3b3",
    "userId": "344844a8-1021-7022-adb9-65ed4dd64f25",
    "title": "TC002-available_times_api",
    "description": "Verify the available times API endpoint dynamically generates 20-minute interval time slots based on the doctor's work schedule, existing appointments, and unavailable times. Ensure that booked or blocked slots are excluded and the response reflects accurate availability.",
    "code": "import requests\n\ndef test_available_times_api():\n    base_url = \"http://localhost:3000/api\"\n    endpoint = f\"{base_url}/available-times\"\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n    timeout = 30\n\n    from datetime import datetime, timedelta\n    test_date = (datetime.utcnow() + timedelta(days=3)).date().isoformat()\n\n    url = f\"{endpoint}/{test_date}\"\n    try:\n        response = requests.get(url, headers=headers, timeout=timeout)\n    except requests.RequestException as e:\n        assert False, f\"Request to available-times API failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    assert isinstance(data, list), \"Response JSON must be a list of time slots\"\n\n    import re\n    time_slot_pattern = re.compile(r\"^([01]\\d|2[0-3]):(00|20|40)$\")\n\n    for slot in data:\n        assert isinstance(slot, str), f\"Time slot is not a string: {slot}\"\n        assert time_slot_pattern.match(slot), f\"Time slot '{slot}' does not match 20-minute interval format HH:mm\"\n\n    for slot in data:\n        hour, minute = map(int, slot.split(\":\"))\n        assert (8 <= hour <= 18), f\"Time slot '{slot}' outside expected working hours 08:00-18:00\"\n        assert minute in (0, 20, 40), f\"Time slot '{slot}' minute part is not 00, 20 or 40\"\n\n    assert data == sorted(data), \"Time slots are not sorted ascending\"\n    assert len(data) == len(set(data)), \"Duplicate time slots found\"\n\ntest_available_times_api()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 44, in <module>\n  File \"<string>\", line 20, in test_available_times_api\nAssertionError: Expected status code 200, got 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-19T17:33:30.273Z",
    "modified": "2026-01-19T17:34:30.164Z"
  },
  {
    "projectId": "d3f9883c-1816-4052-bf75-e4e8e200692e",
    "testId": "0615ce22-21e5-4a5c-a4f0-1604bae806d1",
    "userId": "344844a8-1021-7022-adb9-65ed4dd64f25",
    "title": "TC003-admin_authentication_api",
    "description": "Test the admin authentication API endpoints including login, logout, password reset, and token verification. Validate JWT token issuance, secure password reset flows, and access control for protected routes.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000/api\"\nAUTH_CREDENTIALS = {\"email\": \"maxim.degtiarev.dev@gmail.com\", \"password\": \"admin1234\"}\nTIMEOUT = 30\n\ndef test_admin_authentication_api():\n    session = requests.Session()\n    headers = {\"Content-Type\": \"application/json\"}\n\n    token = None\n    reset_token = None\n    try:\n        # 1. Login - POST /auth/login\n        login_resp = session.post(\n            f\"{BASE_URL}/auth/login\",\n            json=AUTH_CREDENTIALS,\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n        assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n        login_data = login_resp.json()\n        assert \"token\" in login_data and isinstance(login_data[\"token\"], str)\n        token = login_data[\"token\"]\n\n        # Use Bearer token for subsequent protected requests\n        auth_headers = {\n            \"Authorization\": f\"Bearer {token}\",\n            \"Content-Type\": \"application/json\",\n        }\n\n        # 2. Verify token - GET /auth/verify\n        verify_resp = session.get(\n            f\"{BASE_URL}/auth/verify\",\n            headers=auth_headers,\n            timeout=TIMEOUT,\n        )\n        assert verify_resp.status_code == 200, f\"Token verification failed: {verify_resp.text}\"\n        verify_data = verify_resp.json()\n        assert verify_data.get(\"valid\") is True\n\n        # 3. Initiate password reset - POST /auth/forgot-password\n        forgot_password_payload = {\"email\": AUTH_CREDENTIALS[\"email\"]}\n        forgot_resp = session.post(\n            f\"{BASE_URL}/auth/forgot-password\",\n            json=forgot_password_payload,\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n        # Should always respond with 200 or similar to not reveal email existence\n        assert forgot_resp.status_code in (200, 202), f\"Forgot password failed: {forgot_resp.text}\"\n\n        # Simulate retrieving reset token from email\n        # Since no explicit API given, assume next step requires a reset token\n        # For test, try to request password reset token via an endpoint if available\n        # Here we skip actual token retrieval due to no PRD detail.\n        #\n        # For demonstration, we assume the reset token received in response for testing purposes:\n        if forgot_resp.status_code == 200:\n            forgot_data = forgot_resp.json()\n            reset_token = forgot_data.get(\"resetToken\")  # May or may not be present\n        if not reset_token:\n            # Cannot test reset-password endpoint without token, so skip reset-password test\n            reset_token = None\n\n        # 4. Reset password - POST /auth/reset-password (only if reset_token present)\n        if reset_token:\n            reset_password_payload = {\n                \"token\": reset_token,\n                \"newPassword\": \"admin1234New!\"\n            }\n            reset_resp = session.post(\n                f\"{BASE_URL}/auth/reset-password\",\n                json=reset_password_payload,\n                headers=headers,\n                timeout=TIMEOUT,\n            )\n            assert reset_resp.status_code == 200, f\"Password reset failed: {reset_resp.text}\"\n            reset_data = reset_resp.json()\n            assert reset_data.get(\"success\") is True\n\n        # 5. Access protected route example: GET /auth/verify\n        protected_resp = session.get(\n            f\"{BASE_URL}/auth/verify\",\n            headers=auth_headers,\n            timeout=TIMEOUT,\n        )\n        assert protected_resp.status_code == 200, f\"Access to protected route failed: {protected_resp.text}\"\n\n        # 6. Logout - POST /auth/logout\n        logout_resp = session.post(\n            f\"{BASE_URL}/auth/logout\",\n            headers=auth_headers,\n            timeout=TIMEOUT,\n        )\n        assert logout_resp.status_code == 200, f\"Logout failed: {logout_resp.text}\"\n        logout_data = logout_resp.json()\n        assert logout_data.get(\"success\") is True\n\n        # 7. Verify token is invalid after logout - GET /auth/verify\n        verify_after_logout = session.get(\n            f\"{BASE_URL}/auth/verify\",\n            headers=auth_headers,\n            timeout=TIMEOUT,\n        )\n        # Expect failure (401 Unauthorized or 403 Forbidden)\n        assert verify_after_logout.status_code in (401, 403)\n\n    finally:\n        session.close()\n\ntest_admin_authentication_api()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 112, in <module>\n  File \"<string>\", line 23, in test_admin_authentication_api\nAssertionError\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-19T17:33:30.279Z",
    "modified": "2026-01-19T17:34:58.267Z"
  },
  {
    "projectId": "d3f9883c-1816-4052-bf75-e4e8e200692e",
    "testId": "04fc107b-90db-4a48-ac29-84ba9b00ffe4",
    "userId": "344844a8-1021-7022-adb9-65ed4dd64f25",
    "title": "TC004-patient_management_api",
    "description": "Test CRUD operations for patient records via the patient management API endpoints. Validate phone number format, required fields, and proper handling of patient data.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000/api\"\nHEADERS = {\n    \"Content-Type\": \"application/json\",\n    \"Accept\": \"application/json\",\n}\n\nTIMEOUT = 30\n\n\ndef test_patient_management_api():\n    patient_url = f\"{BASE_URL}/patients\"\n\n    # Sample valid patient data\n    valid_patient = {\n        \"firstName\": \"John\",\n        \"lastName\": \"Doe\",\n        \"email\": \"john.doe@example.com\",\n        \"phone\": \"+12025550123\"\n    }\n\n    # Sample invalid phone format patient data (invalid format)\n    invalid_phone_patient = {\n        \"firstName\": \"Jane\",\n        \"lastName\": \"Smith\",\n        \"email\": \"jane.smith@example.com\",\n        \"phone\": \"invalid-phone\"\n    }\n\n    # Sample data missing required fields (missing email)\n    missing_field_patient = {\n        \"firstName\": \"Alice\",\n        \"lastName\": \"Brown\",\n        \"phone\": \"+12025550123\"\n    }\n\n    patient_id = None\n\n    try:\n        # CREATE patient with valid data\n        create_resp = requests.post(\n            patient_url,\n            headers=HEADERS,\n            json=valid_patient,\n            timeout=TIMEOUT,\n        )\n        assert create_resp.status_code == 201, f\"Expected 201 created, got {create_resp.status_code}\"\n        created_patient = create_resp.json()\n        assert \"id\" in created_patient, \"Patient ID not returned on creation\"\n        patient_id = created_patient[\"id\"]\n\n        # READ - Get the created patient by ID\n        get_resp = requests.get(\n            f\"{patient_url}/{patient_id}\",\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert get_resp.status_code == 200, f\"Expected 200 OK, got {get_resp.status_code}\"\n        fetched_patient = get_resp.json()\n        assert fetched_patient[\"id\"] == patient_id, \"Fetched patient ID mismatch\"\n        assert fetched_patient[\"phone\"] == valid_patient[\"phone\"], \"Phone number mismatch on fetch\"\n\n        # UPDATE patient - change phone number to a new valid format\n        updated_data = {\"phone\": \"+13105550199\"}\n        update_resp = requests.put(\n            f\"{patient_url}/{patient_id}\",\n            headers=HEADERS,\n            json=updated_data,\n            timeout=TIMEOUT,\n        )\n        assert update_resp.status_code == 200, f\"Expected 200 OK on update, got {update_resp.status_code}\"\n        updated_patient = update_resp.json()\n        assert updated_patient[\"phone\"] == updated_data[\"phone\"], \"Phone number update failed\"\n\n        # VALIDATION TESTS\n\n        # Attempt to create patient with invalid phone format\n        invalid_phone_resp = requests.post(\n            patient_url,\n            headers=HEADERS,\n            json=invalid_phone_patient,\n            timeout=TIMEOUT,\n        )\n        assert invalid_phone_resp.status_code == 400, \"Expected 400 Bad Request for invalid phone format\"\n        invalid_phone_json = invalid_phone_resp.json()\n        assert \"phone\" in str(invalid_phone_json).lower(), \"Response should indicate phone number validation error\"\n\n        # Attempt to create patient missing required fields\n        missing_field_resp = requests.post(\n            patient_url,\n            headers=HEADERS,\n            json=missing_field_patient,\n            timeout=TIMEOUT,\n        )\n        assert missing_field_resp.status_code == 400, \"Expected 400 Bad Request for missing required fields\"\n        missing_field_json = missing_field_resp.json()\n        # Check error message references missing required field(s)\n        missing_fields_lower = str(missing_field_json).lower()\n        assert (\n            \"email\" in missing_fields_lower or \"required\" in missing_fields_lower\n        ), \"Response should indicate missing required fields\"\n\n    finally:\n        # DELETE patient resource if created\n        if patient_id:\n            delete_resp = requests.delete(\n                f\"{patient_url}/{patient_id}\",\n                headers=HEADERS,\n                timeout=TIMEOUT,\n            )\n            assert delete_resp.status_code in (200, 204), f\"Expected 200 or 204 on delete, got {delete_resp.status_code}\"\n\n\ntest_patient_management_api()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 115, in <module>\n  File \"<string>\", line 48, in test_patient_management_api\nAssertionError: Expected 201 created, got 400\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-19T17:33:30.289Z",
    "modified": "2026-01-19T17:34:58.282Z"
  },
  {
    "projectId": "d3f9883c-1816-4052-bf75-e4e8e200692e",
    "testId": "f9b4678f-0494-4beb-8329-45a5c2badbac",
    "userId": "344844a8-1021-7022-adb9-65ed4dd64f25",
    "title": "TC005-appointment_cancellation_api",
    "description": "Test the secure appointment cancellation API with token verification. Ensure cancellation requests adhere to the 24-hour policy, reject last-minute cancellations within 12 hours, and verify proper status updates and error handling.",
    "code": "import requests\nfrom datetime import datetime, timedelta\nimport uuid\n\nBASE_URL = \"http://localhost:3000/api\"\nHEADERS = {\"Content-Type\": \"application/json\"}\nTIMEOUT = 30\n\n\ndef test_appointment_cancellation_api():\n    appointment_id = None\n    cancellation_token = None\n\n    try:\n        # Step 1: Create a new appointment with a date/time more than 24 hours in the future (valid cancellation window)\n        future_datetime = (datetime.utcnow() + timedelta(days=2)).replace(microsecond=0).isoformat() + \"Z\"\n        patient_data = {\n            \"first_name\": \"Test\",\n            \"last_name\": \"Patient\",\n            \"phone_number\": \"+12345678901\"\n        }\n        # Create patient record\n        patient_resp = requests.post(\n            f\"{BASE_URL}/patients\",\n            json=patient_data,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert patient_resp.status_code == 201, f\"Patient creation failed: {patient_resp.text}\"\n        patient_id = patient_resp.json().get(\"id\")\n        assert patient_id, \"Patient ID missing in response\"\n\n        # Book appointment for the patient\n        appointment_request = {\n            \"patient_id\": patient_id,\n            \"visit_type\": \"Consulta\",\n            \"consult_type\": \"Seguimiento\",\n            \"practice_type\": \"General\",\n            \"health_insurance\": \"Publica\",\n            \"appointment_date\": future_datetime,\n            \"notes\": \"Test appointment for cancellation\"\n        }\n\n        appt_resp = requests.post(\n            f\"{BASE_URL}/appointments\",\n            json=appointment_request,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert appt_resp.status_code == 201, f\"Appointment creation failed: {appt_resp.text}\"\n        appt_json = appt_resp.json()\n        appointment_id = appt_json.get(\"id\")\n        cancellation_token = appt_json.get(\"cancellation_token\")\n        assert appointment_id, \"Appointment ID missing in response\"\n        assert cancellation_token, \"Cancellation token missing in response\"\n\n        # Step 2: Attempt valid cancellation >24 hours before appointment - should succeed\n        cancel_resp = requests.post(\n            f\"{BASE_URL}/cancel-appointment\",\n            json={\"appointment_id\": appointment_id, \"token\": cancellation_token},\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert cancel_resp.status_code == 200, f\"Cancellation failed unexpectedly: {cancel_resp.text}\"\n        cancel_json = cancel_resp.json()\n        assert cancel_json.get(\"status\") == \"cancelled\", \"Appointment status not updated to cancelled\"\n\n        # Step 3: Book an appointment within 12 hours to test last-minute cancellation rejection\n        near_datetime = (datetime.utcnow() + timedelta(hours=10)).replace(microsecond=0).isoformat() + \"Z\"\n        appointment_request_urgent = {\n            \"patient_id\": patient_id,\n            \"visit_type\": \"Consulta\",\n            \"consult_type\": \"Primera vez\",\n            \"practice_type\": \"General\",\n            \"health_insurance\": \"Publica\",\n            \"appointment_date\": near_datetime,\n            \"notes\": \"Urgent appointment to test last-minute cancellation\"\n        }\n        appt_resp_urgent = requests.post(\n            f\"{BASE_URL}/appointments\",\n            json=appointment_request_urgent,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert appt_resp_urgent.status_code == 201, f\"Urgent appointment creation failed: {appt_resp_urgent.text}\"\n        appt_urgent_json = appt_resp_urgent.json()\n        appointment_id_urgent = appt_urgent_json.get(\"id\")\n        cancellation_token_urgent = appt_urgent_json.get(\"cancellation_token\")\n        assert appointment_id_urgent, \"Urgent appointment ID missing\"\n        assert cancellation_token_urgent, \"Urgent cancellation token missing\"\n\n        # Step 4: Attempt cancellation less than 12 hours before appointment - should reject\n        cancel_resp_urgent = requests.post(\n            f\"{BASE_URL}/cancel-appointment\",\n            json={\"appointment_id\": appointment_id_urgent, \"token\": cancellation_token_urgent},\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert cancel_resp_urgent.status_code == 400 or cancel_resp_urgent.status_code == 403, (\n            \"Last-minute cancellation within 12 hours should be rejected\"\n        )\n        cancel_error_json = cancel_resp_urgent.json()\n        assert \"error\" in cancel_error_json or \"message\" in cancel_error_json, \"Error message expected for last-minute cancellation\"\n\n        # Step 5: Attempt cancellation with invalid token - should reject\n        invalid_token_resp = requests.post(\n            f\"{BASE_URL}/cancel-appointment\",\n            json={\"appointment_id\": appointment_id_urgent, \"token\": \"invalid-token-123\"},\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert invalid_token_resp.status_code == 401 or invalid_token_resp.status_code == 403, \"Invalid token cancellation should be unauthorized\"\n        invalid_token_json = invalid_token_resp.json()\n        assert \"error\" in invalid_token_json or \"message\" in invalid_token_json, \"Error message expected for invalid token\"\n\n    finally:\n        # Cleanup appointments if they still exist\n        if appointment_id:\n            requests.delete(f\"{BASE_URL}/appointments/{appointment_id}\", timeout=TIMEOUT)\n        if 'appointment_id_urgent' in locals() and appointment_id_urgent:\n            requests.delete(f\"{BASE_URL}/appointments/{appointment_id_urgent}\", timeout=TIMEOUT)\n        if 'patient_id' in locals() and patient_id:\n            requests.delete(f\"{BASE_URL}/patients/{patient_id}\", timeout=TIMEOUT)\n\n\ntest_appointment_cancellation_api()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 126, in <module>\n  File \"<string>\", line 31, in test_appointment_cancellation_api\nAssertionError: Patient ID missing in response\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-19T17:33:30.295Z",
    "modified": "2026-01-19T17:35:27.888Z"
  },
  {
    "projectId": "d3f9883c-1816-4052-bf75-e4e8e200692e",
    "testId": "3d04fd2a-d581-4f3c-aedd-4648146074e9",
    "userId": "344844a8-1021-7022-adb9-65ed4dd64f25",
    "title": "TC006-work_schedule_management_api",
    "description": "Verify the work schedule management API endpoints allow admin users to configure the doctor's work schedule. Validate creation, update, and retrieval of schedule data and ensure proper access control.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:3000/api\"\nAUTH = HTTPBasicAuth(\"maxim.degtiarev.dev@gmail.com\", \"admin1234\")\nHEADERS = {\"Content-Type\": \"application/json\"}\nTIMEOUT = 30\n\ndef test_work_schedule_management_api():\n    schedule_id = None\n    try:\n        # 1. Create a new work schedule (POST)\n        create_payload = {\n            \"doctorId\": \"doctor-001\",\n            \"weekdays\": [\n                {\"day\": \"lunes\", \"startTime\": \"09:00\", \"endTime\": \"17:00\"},\n                {\"day\": \"martes\", \"startTime\": \"09:00\", \"endTime\": \"17:00\"},\n                {\"day\": \"miércoles\", \"startTime\": \"09:00\", \"endTime\": \"17:00\"},\n                {\"day\": \"jueves\", \"startTime\": \"09:00\", \"endTime\": \"17:00\"},\n                {\"day\": \"viernes\", \"startTime\": \"09:00\", \"endTime\": \"17:00\"}\n            ],\n            \"unavailableDates\": [],\n            \"unavailableTimes\": []\n        }\n        create_resp = requests.post(\n            f\"{BASE_URL}/work-schedule\",\n            json=create_payload,\n            auth=AUTH,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert create_resp.status_code == 201, f\"Expected 201 Created, got {create_resp.status_code}\"\n        created_data = create_resp.json()\n        assert \"id\" in created_data, \"Response missing schedule id\"\n        schedule_id = created_data[\"id\"]\n\n        # 2. Retrieve the created schedule (GET)\n        get_resp = requests.get(\n            f\"{BASE_URL}/work-schedule/{schedule_id}\",\n            auth=AUTH,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert get_resp.status_code == 200, f\"Expected 200 OK on retrieval, got {get_resp.status_code}\"\n        get_data = get_resp.json()\n        assert get_data[\"doctorId\"] == create_payload[\"doctorId\"], \"Doctor ID mismatch in retrieved schedule\"\n        assert isinstance(get_data[\"weekdays\"], list) and len(get_data[\"weekdays\"]) == 5, \"Weekdays data mismatch\"\n\n        # 3. Update the work schedule (PUT)\n        update_payload = {\n            \"weekdays\": [\n                {\"day\": \"lunes\", \"startTime\": \"10:00\", \"endTime\": \"16:00\"},\n                {\"day\": \"martes\", \"startTime\": \"10:00\", \"endTime\": \"16:00\"},\n                {\"day\": \"miércoles\", \"startTime\": \"10:00\", \"endTime\": \"16:00\"},\n                {\"day\": \"jueves\", \"startTime\": \"10:00\", \"endTime\": \"16:00\"},\n                {\"day\": \"viernes\", \"startTime\": \"10:00\", \"endTime\": \"16:00\"}\n            ],\n            \"unavailableDates\": [\"2026-01-20\"],\n            \"unavailableTimes\": [\n                {\"date\": \"2026-01-21\", \"startTime\": \"12:00\", \"endTime\": \"13:00\"}\n            ]\n        }\n        update_resp = requests.put(\n            f\"{BASE_URL}/work-schedule/{schedule_id}\",\n            json=update_payload,\n            auth=AUTH,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert update_resp.status_code in (200,204), f\"Expected 200 OK or 204 No Content on update, got {update_resp.status_code}\"\n\n        # 4. Retrieve the updated schedule to verify changes\n        get_updated_resp = requests.get(\n            f\"{BASE_URL}/work-schedule/{schedule_id}\",\n            auth=AUTH,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert get_updated_resp.status_code == 200, f\"Expected 200 OK on retrieval, got {get_updated_resp.status_code}\"\n        updated_data = get_updated_resp.json()\n        assert updated_data[\"weekdays\"][0][\"startTime\"] == \"10:00\", \"Update of startTime failed\"\n        assert \"2026-01-20\" in updated_data.get(\"unavailableDates\", []), \"Unavailable date not updated\"\n        assert any(t.get(\"startTime\") == \"12:00\" for t in updated_data.get(\"unavailableTimes\", [])), \"Unavailable time not updated\"\n\n        # 5. Access control test - unauthorized access\n        unauthorized_resp = requests.get(\n            f\"{BASE_URL}/work-schedule/{schedule_id}\",\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        # Expect unauthorized (401 or 403)\n        assert unauthorized_resp.status_code in (401, 403), f\"Expected 401/403 for unauthorized access, got {unauthorized_resp.status_code}\"\n\n    finally:\n        # Cleanup: delete the created work schedule if created\n        if schedule_id:\n            delete_resp = requests.delete(\n                f\"{BASE_URL}/work-schedule/{schedule_id}\",\n                auth=AUTH,\n                headers=HEADERS,\n                timeout=TIMEOUT\n            )\n            # Accept 200 OK, 204 No Content or 404 Not Found if already deleted\n            assert delete_resp.status_code in (200, 204, 404), f\"Unexpected status code on cleanup delete: {delete_resp.status_code}\"\n\ntest_work_schedule_management_api()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 106, in <module>\n  File \"<string>\", line 32, in test_work_schedule_management_api\nAssertionError: Expected 201 Created, got 400\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-19T17:33:30.300Z",
    "modified": "2026-01-19T17:35:18.619Z"
  },
  {
    "projectId": "d3f9883c-1816-4052-bf75-e4e8e200692e",
    "testId": "9dd1e7a2-cbb3-4f9a-be02-19e69e59ce7f",
    "userId": "344844a8-1021-7022-adb9-65ed4dd64f25",
    "title": "TC007-unavailable_days_management_api",
    "description": "Test the unavailable days management API to mark specific dates as holidays or vacations. Validate that these dates are excluded from available appointment slots and properly stored.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\nimport datetime\nimport json\n\nBASE_URL = \"http://localhost:3000/api\"\nUSERNAME = \"maxim.degtiarev.dev@gmail.com\"\nPASSWORD = \"admin1234\"\nTIMEOUT = 30\n\nauth = HTTPBasicAuth(USERNAME, PASSWORD)\nheaders = {\"Content-Type\": \"application/json\"}\n\ndef test_unavailable_days_management_api():\n    # Prepare a test date for marking as unavailable\n    test_date = (datetime.date.today() + datetime.timedelta(days=10)).isoformat()\n    unavailable_payload = {\n        \"unavailableDate\": test_date,\n        \"reason\": \"holiday\",\n        \"description\": \"Test holiday marking\"\n    }\n\n    created = False\n    try:\n        # 1) Create a new unavailable day (POST /unavailable-days)\n        create_resp = requests.post(\n            f\"{BASE_URL}/unavailable-days\",\n            headers=headers,\n            auth=auth,\n            data=json.dumps(unavailable_payload),\n            timeout=TIMEOUT\n        )\n        assert create_resp.status_code == 201, f\"Failed to create unavailable day: {create_resp.text}\"\n        created = True\n        create_data = create_resp.json()\n        # Validate response contains the date and reason stored correctly\n        assert create_data.get(\"unavailableDate\") == test_date, \"Stored date does not match\"\n        assert create_data.get(\"reason\") == \"holiday\", \"Stored reason does not match\"\n\n        # 2) Retrieve unavailable day by date (GET /unavailable-days/[date])\n        get_resp = requests.get(\n            f\"{BASE_URL}/unavailable-days/{test_date}\",\n            headers=headers,\n            auth=auth,\n            timeout=TIMEOUT\n        )\n        assert get_resp.status_code == 200, f\"Failed to get unavailable day: {get_resp.text}\"\n        get_data = get_resp.json()\n        assert get_data.get(\"unavailableDate\") == test_date, \"Retrieved date does not match\"\n        assert get_data.get(\"reason\") == \"holiday\", \"Retrieved reason does not match\"\n\n        # 3) Verify unavailable day affects available appointment slots\n        # Check available times on the unavailable day (GET /available-times/[date])\n        available_times_resp = requests.get(\n            f\"{BASE_URL}/available-times/{test_date}\",\n            headers=headers,\n            auth=auth,\n            timeout=TIMEOUT\n        )\n        # Expecting no available slots on an unavailable day (holiday)\n        # The API may return 200 with empty list or specific indication\n        assert available_times_resp.status_code == 200, f\"Failed to get available times: {available_times_resp.text}\"\n        times_data = available_times_resp.json()\n\n        # times_data is expected to be empty or no available slots\n        if isinstance(times_data, list):\n            assert len(times_data) == 0, \"Available times should be empty on unavailable day\"\n        elif isinstance(times_data, dict) and \"availableTimes\" in times_data:\n            assert len(times_data[\"availableTimes\"]) == 0, \"Available times should be empty on unavailable day\"\n        else:\n            assert False, \"Unexpected available times response format\"\n\n    finally:\n        if created:\n            # Clean up: delete the created unavailable day (DELETE /unavailable-days/[date])\n            delete_resp = requests.delete(\n                f\"{BASE_URL}/unavailable-days/{test_date}\",\n                headers=headers,\n                auth=auth,\n                timeout=TIMEOUT\n            )\n            # Accept 204 No Content or 200 OK on delete\n            assert delete_resp.status_code in [200, 204], f\"Failed to delete unavailable day: {delete_resp.text}\"\n\n\ntest_unavailable_days_management_api()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 86, in <module>\n  File \"<string>\", line 33, in test_unavailable_days_management_api\nAssertionError: Failed to create unavailable day: {\"error\":\"Date is required\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-19T17:33:30.306Z",
    "modified": "2026-01-19T17:35:22.516Z"
  },
  {
    "projectId": "d3f9883c-1816-4052-bf75-e4e8e200692e",
    "testId": "7f0168fe-dc34-4517-9d3b-56c432a6a235",
    "userId": "344844a8-1021-7022-adb9-65ed4dd64f25",
    "title": "TC008-health_insurance_management_api",
    "description": "Test the health insurance management API endpoint to retrieve health insurance options with pricing information. Validate data accuracy and response format.",
    "code": "import requests\n\ndef test_health_insurance_management_api():\n    base_url = \"http://localhost:3000\"\n    endpoint = f\"{base_url}/api/health-insurance\"\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n\n    try:\n        response = requests.get(endpoint, headers=headers, timeout=30)\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    # Assert status code is 200 OK\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    # Validate that data is a list (array) of health insurance options\n    assert isinstance(data, list), \"Expected response to be a list\"\n\n    # Each item should be a dict with required keys\n    required_keys = {\"id\", \"name\", \"pricing\"}\n    for item in data:\n        assert isinstance(item, dict), \"Each health insurance item should be a dict\"\n        missing_keys = required_keys - item.keys()\n        assert not missing_keys, f\"Missing keys in item: {missing_keys}\"\n        # Validate id is non-empty string or int\n        assert isinstance(item[\"id\"], (str, int)) and item[\"id\"], \"Invalid 'id' value\"\n        # Validate name is non-empty string\n        assert isinstance(item[\"name\"], str) and item[\"name\"].strip(), \"Invalid 'name' value\"\n        # Validate pricing is a dict with numeric values\n        pricing = item[\"pricing\"]\n        assert isinstance(pricing, dict), \"'pricing' should be a dictionary\"\n        for price_key, price_value in pricing.items():\n            assert isinstance(price_value, (int, float)), f\"Pricing value for '{price_key}' is not numeric\"\n\ntest_health_insurance_management_api()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 42, in <module>\n  File \"<string>\", line 31, in test_health_insurance_management_api\nAssertionError: Missing keys in item: {'pricing', 'id'}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-19T17:33:30.312Z",
    "modified": "2026-01-19T17:35:18.617Z"
  },
  {
    "projectId": "d3f9883c-1816-4052-bf75-e4e8e200692e",
    "testId": "acf6e965-e729-41a2-a991-55f1d1852c8f",
    "userId": "344844a8-1021-7022-adb9-65ed4dd64f25",
    "title": "TC009-push_notifications_api",
    "description": "Test the push notifications API endpoints for subscribing, unsubscribing, and sending notifications. Validate subscription storage, VAPID key usage, and delivery of notifications.",
    "code": "import requests\nimport json\n\nBASE_URL = \"http://localhost:3000/api/push\"\n\nHEADERS = {\n    \"Content-Type\": \"application/json\",\n}\n\ndef test_push_notifications_api():\n    subscription_endpoint = f\"{BASE_URL}/subscribe\"\n    unsubscribe_endpoint = f\"{BASE_URL}/unsubscribe\"\n    send_endpoint = f\"{BASE_URL}/send\"\n\n    # Sample subscription payload simulating a browser's push subscription object\n    subscription_payload = {\n        \"subscription\": {\n            \"endpoint\": \"https://fcm.googleapis.com/fcm/send/fake-endpoint-for-testing\",\n            \"expirationTime\": None,\n            \"keys\": {\n                \"p256dh\": \"BM8CfaZUPPyEKx6UQjxdsqAS5yBJRZxWly5XnOv5l5SWrmn5Z_LcVZHFxDrF4ph3e6_yEwh0y96k1vQ-_UsThR_8\",\n                \"auth\": \"NPNcWITmZcShpnlY_fI03A\"\n            }\n        }\n    }\n\n    # Subscribe user for push notifications\n    response_subscribe = requests.post(\n        subscription_endpoint,\n        headers=HEADERS,\n        data=json.dumps(subscription_payload),\n        timeout=30\n    )\n    assert response_subscribe.status_code in (200, 201), \\\n        f\"Subscribe request failed with status {response_subscribe.status_code}, response: {response_subscribe.text}\"\n    subscribe_resp_json = response_subscribe.json()\n    assert 'id' in subscribe_resp_json or 'subscription' in subscribe_resp_json, \\\n        \"Subscribe response missing subscription confirmation\"\n\n    # Sending a push notification to the subscribed user\n    notification_payload = {\n        \"subscription\": subscription_payload[\"subscription\"],\n        \"notification\": {\n            \"title\": \"Test Notification\",\n            \"body\": \"This is a test push notification from automated test.\",\n            \"icon\": \"/icons/icon-192x192.png\",\n            \"vibrate\": [100, 50, 100],\n            \"data\": {\"url\": \"https://localhost:3000/\"},\n            \"actions\": [\n                {\"action\": \"open_url\", \"title\": \"Open App\"}\n            ]\n        }\n    }\n\n    response_send = requests.post(\n        send_endpoint,\n        headers=HEADERS,\n        data=json.dumps(notification_payload),\n        timeout=30\n    )\n    assert response_send.status_code in (200, 201), \\\n        f\"Send notification failed with status {response_send.status_code}, response: {response_send.text}\"\n\n    # Unsubscribe / remove the subscription to clean up\n    try:\n        response_unsubscribe = requests.post(\n            unsubscribe_endpoint,\n            headers=HEADERS,\n            data=json.dumps(subscription_payload),\n            timeout=30\n        )\n        assert response_unsubscribe.status_code in (200, 204), \\\n            f\"Unsubscribe request failed with status {response_unsubscribe.status_code}, response: {response_unsubscribe.text}\"\n    except Exception as e:\n        # If unsubscribe fails, log but do not fail the test here\n        print(f\"Unsubscribe cleanup failed: {e}\")\n\n\ntest_push_notifications_api()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 79, in <module>\n  File \"<string>\", line 34, in test_push_notifications_api\nAssertionError: Subscribe request failed with status 500, response: {\"error\":\"Failed to save subscription\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-19T17:33:30.317Z",
    "modified": "2026-01-19T17:35:39.389Z"
  },
  {
    "projectId": "d3f9883c-1816-4052-bf75-e4e8e200692e",
    "testId": "e9f92db9-724c-446a-a821-19667b0ccd96",
    "userId": "344844a8-1021-7022-adb9-65ed4dd64f25",
    "title": "TC010-rate_limiting_api",
    "description": "Verify the API rate limiting functionality to ensure it effectively limits excessive requests while allowing legitimate users to access the system without disruption.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000/admin\"\nLOGIN_URL = \"http://localhost:3000/api/auth/login\"\nUSERNAME = \"maxim.degtiarev.dev@gmail.com\"\nPASSWORD = \"admin1234\"\nTIMEOUT = 30\n\n\ndef test_rate_limiting_api():\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n\n    # Authenticate to get JWT token\n    login_payload = {\n        \"email\": USERNAME,\n        \"password\": PASSWORD\n    }\n\n    login_response = requests.post(LOGIN_URL, json=login_payload, headers={\"Accept\": \"application/json\"}, timeout=TIMEOUT)\n    assert login_response.status_code == 200, f\"Login failed with status code {login_response.status_code}\"\n    json_response = login_response.json()\n    token = json_response.get(\"token\") or json_response.get(\"access_token\")\n    assert token is not None, \"No token found in login response\"\n\n    auth_headers = headers.copy()\n    auth_headers[\"Authorization\"] = f\"Bearer {token}\"\n\n    test_endpoint = f\"{BASE_URL}/work-schedule\"\n\n    success_responses = 0\n    rate_limit_responses = 0\n    other_error_responses = 0\n\n    total_requests = 20\n\n    for _ in range(total_requests):\n        try:\n            response = requests.get(test_endpoint, headers=auth_headers, timeout=TIMEOUT)\n            if response.status_code == 200:\n                success_responses += 1\n            elif response.status_code == 429:\n                rate_limit_responses += 1\n            else:\n                other_error_responses += 1\n        except requests.RequestException:\n            other_error_responses += 1\n\n    assert success_responses > 0, \"No successful responses received, legitimate users may be blocked.\"\n    assert rate_limit_responses > 0, \"Rate limiting was not enforced, no 429 responses received.\"\n    assert other_error_responses == 0, f\"Unexpected errors occurred during requests: {other_error_responses}\"\n\n\ntest_rate_limiting_api()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 55, in <module>\n  File \"<string>\", line 25, in test_rate_limiting_api\nAssertionError: No token found in login response\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-19T17:33:30.323Z",
    "modified": "2026-01-19T17:35:46.563Z"
  }
]
