[
  {
    "projectId": "6432887a-63b1-493b-b972-08963b570a3b",
    "testId": "7013152e-08cf-4c4e-9812-c22b66e39526",
    "userId": "344844a8-1021-7022-adb9-65ed4dd64f25",
    "title": "TC001-patient appointment scheduling",
    "description": "Test the appointment scheduling API to ensure patients can book appointments with valid inputs including date, time, visit type, consult type, practice type, and health insurance selection. Verify real-time availability and validation.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\nfrom datetime import datetime, timedelta\nimport uuid\n\nBASE_URL = \"http://localhost:3000/api\"\nAUTH = HTTPBasicAuth(\"maxim.degtiarev.dev@gmail.com\", \"admin1234\")\nHEADERS = {\n    \"Content-Type\": \"application/json\",\n    \"Accept\": \"application/json\"\n}\nTIMEOUT = 30\n\n\ndef test_patient_appointment_scheduling():\n    # Step 1: Fetch visit types\n    visit_types_resp = requests.get(f\"{BASE_URL}/visit-types\", auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n    assert visit_types_resp.status_code == 200, f\"Failed to fetch visit types: {visit_types_resp.text}\"\n    visit_types = visit_types_resp.json()\n    assert isinstance(visit_types, list) and len(visit_types) > 0, \"Visit types should be a non-empty list\"\n    visit_type = visit_types[0]\n\n    # Step 2: Fetch consult types\n    consult_types_resp = requests.get(f\"{BASE_URL}/consult-types\", auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n    assert consult_types_resp.status_code == 200, f\"Failed to fetch consult types: {consult_types_resp.text}\"\n    consult_types = consult_types_resp.json()\n    assert isinstance(consult_types, list) and len(consult_types) > 0, \"Consult types should be a non-empty list\"\n    consult_type = consult_types[0]\n\n    # Step 3: Fetch health insurances\n    health_insurance_resp = requests.get(f\"{BASE_URL}/health-insurance\", auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n    assert health_insurance_resp.status_code == 200, f\"Failed to fetch health insurance: {health_insurance_resp.text}\"\n    health_insurances = health_insurance_resp.json()\n    assert isinstance(health_insurances, list) and len(health_insurances) > 0, \"Health insurances should be a non-empty list\"\n    health_insurance = health_insurances[0]\n\n    # Step 4: Choose a practice type from visit_type if exists or fallback sample string\n    if 'practiceType' in visit_type:\n        practice_type = visit_type['practiceType']\n    elif 'practice_type' in visit_type:\n        practice_type = visit_type['practice_type']\n    else:\n        practice_type = \"Dermatology\"  # sample fallback\n\n    # Step 5: Determine a date with available times\n    target_date = (datetime.utcnow() + timedelta(days=3)).strftime(\"%Y-%m-%d\")\n    available_times_resp = requests.get(f\"{BASE_URL}/available-times/{target_date}\", auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n    assert available_times_resp.status_code == 200, f\"Failed to fetch available times for date {target_date}: {available_times_resp.text}\"\n    available_times = available_times_resp.json()\n    assert isinstance(available_times, list) and len(available_times) > 0, \"Available times should be a non-empty list for a valid date\"\n    appointment_time = available_times[0]\n\n    # Step 6: Create a patient record (POST to /patients) or verify if patient exists to avoid duplicates\n    unique_email = f\"test.patient.{uuid.uuid4()}@example.com\"\n    patient_payload = {\n        \"firstName\": \"Test\",\n        \"lastName\": \"Patient\",\n        \"email\": unique_email,\n        \"phoneNumber\": f\"+1234567{str(uuid.uuid4().int)[:7]}\",\n        \"birthDate\": \"1990-01-01\",\n        \"gender\": \"other\",\n    }\n    patient_resp = requests.post(f\"{BASE_URL}/patients\", auth=AUTH, headers=HEADERS, json=patient_payload, timeout=TIMEOUT)\n    assert patient_resp.status_code == 201, f\"Failed to create patient: {patient_resp.text}\"\n    patient_data = patient_resp.json()\n    assert \"id\" in patient_data, \"Patient creation response must include 'id'\"\n    patient_id = patient_data[\"id\"]\n\n    # Step 7: Book appointment\n    appointment_payload = {\n        \"patientId\": patient_id,\n        \"date\": target_date,\n        \"time\": appointment_time,\n        \"visitType\": visit_type.get(\"id\") or visit_type.get(\"ID\") or visit_type,\n        \"consultType\": consult_type.get(\"id\") or consult_type.get(\"ID\") or consult_type,\n        \"practiceType\": practice_type,\n        \"healthInsurance\": health_insurance.get(\"id\") or health_insurance.get(\"ID\") or health_insurance,\n    }\n    appointment_resp = requests.post(f\"{BASE_URL}/appointments/create\", auth=AUTH, headers=HEADERS, json=appointment_payload, timeout=TIMEOUT)\n    try:\n        assert appointment_resp.status_code == 201, f\"Failed to create appointment: {appointment_resp.text}\"\n        appointment_data = appointment_resp.json()\n        assert appointment_data.get(\"patientId\") == patient_id, \"Appointment patientId mismatch\"\n        assert appointment_data.get(\"date\") == target_date, \"Appointment date mismatch\"\n        assert appointment_data.get(\"time\") == appointment_time, \"Appointment time mismatch\"\n        # Verify returned visitType, consultType, practiceType, and healthInsurance presence and values\n        assert appointment_data.get(\"visitType\") is not None, \"visitType missing in appointment response\"\n        assert appointment_data.get(\"consultType\") is not None, \"consultType missing in appointment response\"\n        assert appointment_data.get(\"practiceType\") is not None, \"practiceType missing in appointment response\"\n        assert appointment_data.get(\"healthInsurance\") is not None, \"healthInsurance missing in appointment response\"\n    finally:\n        # Cleanup: delete appointment\n        appointment_id = appointment_resp.json().get(\"id\")\n        if appointment_id:\n            del_resp = requests.delete(f\"{BASE_URL}/appointments/{appointment_id}\", auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n            assert del_resp.status_code in [200, 204], f\"Failed to delete appointment {appointment_id}: {del_resp.text}\"\n        # Cleanup: delete patient\n        if patient_id:\n            del_patient_resp = requests.delete(f\"{BASE_URL}/patients/{patient_id}\", auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n            assert del_patient_resp.status_code in [200, 204], f\"Failed to delete patient {patient_id}: {del_patient_resp.text}\"\n\n\ntest_patient_appointment_scheduling()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 103, in <module>\n  File \"<string>\", line 48, in test_patient_appointment_scheduling\nAssertionError: Failed to fetch available times for date 2026-01-22: {\"error\":\"No available slots configured for this day of week\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-19T19:00:46.439Z",
    "modified": "2026-01-19T19:02:35.332Z"
  },
  {
    "projectId": "6432887a-63b1-493b-b972-08963b570a3b",
    "testId": "c7fa10ba-827a-44ee-896c-b78f9b42b68d",
    "userId": "344844a8-1021-7022-adb9-65ed4dd64f25",
    "title": "TC002-available times management",
    "description": "Verify the available times API dynamically generates time slots based on the doctor's work schedule, existing appointments, and unavailable times, ensuring no double bookings or invalid slots.",
    "code": "import requests\nfrom datetime import datetime, timedelta\n\nBASE_URL = \"http://localhost:3000/api/available-times\"\nTIMEOUT = 30\n\ndef test_available_times_management():\n    headers = {\n        \"Accept\": \"application/json\",\n        \"Content-Type\": \"application/json\",\n    }\n\n    # For testing, select a date to query available times:\n    # Use tomorrow's date as a sample valid future date with work schedule\n    date_obj = datetime.utcnow().date() + timedelta(days=1)\n    date_str = date_obj.isoformat()\n\n    url = f\"{BASE_URL}/{date_str}\"\n\n    try:\n        # Make GET request to fetch available time slots for the given date\n        response = requests.get(url, headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 200, f\"Expected 200 OK but got {response.status_code}\"\n        data = response.json()\n\n        # Validate the response is a list (array) of time slots\n        assert isinstance(data, list), \"Response should be a list of available time slots\"\n\n        # Each time slot should have expected fields, e.g. time string, and be valid time format\n        for slot in data:\n            assert isinstance(slot, str) or (isinstance(slot, dict) and (\n                \"time\" in slot or \"startTime\" in slot or \"start_time\" in slot\n            )), \"Each time slot should be a string or an object with time properties\"\n            # Validate time format loosely (HH:MM or ISO datetime)\n            time_str = slot if isinstance(slot, str) else (\n                slot.get(\"time\") or slot.get(\"startTime\") or slot.get(\"start_time\")\n            )\n            assert time_str is not None, \"Time slot must contain a time string\"\n            try:\n                # Accept formats like 'HH:MM', 'HH:MM:SS' or ISO8601\n                datetime.strptime(time_str, '%H:%M')\n            except ValueError:\n                try:\n                    datetime.fromisoformat(time_str)\n                except ValueError:\n                    assert False, f\"Invalid time format in slot: {time_str}\"\n\n        # Further logical checks:\n        # 1) No time slot should be in the past (for today)\n        # 2) No duplicated slots in the list\n        unique_slots = set()\n        now = datetime.utcnow()\n        for slot in data:\n            time_str = slot if isinstance(slot, str) else (\n                slot.get(\"time\") or slot.get(\"startTime\") or slot.get(\"start_time\")\n            )\n            # For date today, time slots must be >= now (we tested with tomorrow, so skip this)\n            # Verify uniqueness\n            assert time_str not in unique_slots, f\"Duplicate time slot found: {time_str}\"\n            unique_slots.add(time_str)\n\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_available_times_management()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 65, in <module>\n  File \"<string>\", line 27, in test_available_times_management\nAssertionError: Response should be a list of available time slots\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-19T19:00:46.445Z",
    "modified": "2026-01-19T19:01:47.199Z"
  },
  {
    "projectId": "6432887a-63b1-493b-b972-08963b570a3b",
    "testId": "17af774b-bf0e-4858-8572-24d6a8f6303a",
    "userId": "344844a8-1021-7022-adb9-65ed4dd64f25",
    "title": "TC003-admin authentication and authorization",
    "description": "Test the admin authentication APIs including login, logout, password reset, and token verification. Ensure JWT tokens are issued, stored securely, and validate access to protected routes.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000/api\"\nUSERNAME = \"maxim.degtiarev.dev@gmail.com\"\nPASSWORD = \"admin1234\"\nTIMEOUT = 30\n\ndef test_admin_authentication_and_authorization():\n    session = requests.Session()\n    try:\n        # 1. Login (POST /auth/login)\n        login_url = f\"{BASE_URL}/auth/login\"\n        login_payload = {\n            \"username\": USERNAME,\n            \"password\": PASSWORD\n        }\n        login_headers = {\n            \"Content-Type\": \"application/json\"\n        }\n        login_resp = session.post(login_url, json=login_payload, headers=login_headers, timeout=TIMEOUT)\n        assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n        login_data = login_resp.json()\n        # JWT token should be issued in response, try flexible field names\n        token = login_data.get(\"token\") or login_data.get(\"jwt\") or login_data.get(\"accessToken\")\n        assert token, \"JWT token not present in login response\"\n        # Check if cookie for session or JWT is set (middleware checks cookies)\n        assert any(\"set-cookie\" in k.lower() for k in login_resp.headers), \"No cookies set in login response\"\n\n        # 2. Access a protected route to verify authorization (GET /auth/verify)\n        verify_url = f\"{BASE_URL}/auth/verify\"\n        # Include cookies already stored in session\n        verify_resp = session.get(verify_url, timeout=TIMEOUT)\n        assert verify_resp.status_code == 200, f\"Token verification failed: {verify_resp.text}\"\n        verify_data = verify_resp.json()\n        # Adjusted assertion to check 'email' field matches USERNAME as per PRD user information\n        assert verify_data.get(\"valid\") is True or verify_data.get(\"authenticated\") is True or verify_data.get(\"email\") == USERNAME, \"Token not verified or invalid user info returned\"\n\n        # 3. Password Reset Flow:\n        # (a) Request password reset link/token (POST /auth/forgot-password)\n        forgot_pwd_url = f\"{BASE_URL}/auth/forgot-password\"\n        forgot_payload = {\n            \"email\": USERNAME\n        }\n        forgot_resp = session.post(forgot_pwd_url, json=forgot_payload, headers=login_headers, timeout=TIMEOUT)\n        # Password reset request usually returns 200 with message\n        assert forgot_resp.status_code == 200, f\"Forgot password request failed: {forgot_resp.text}\"\n        forgot_data = forgot_resp.json()\n        # Expect some message or indication\n        assert \"message\" in forgot_data or \"success\" in forgot_data, \"Forgot password response missing confirmation\"\n\n        # NOTE: The actual reset password requires a token from email; we test the request only here.\n        # (b) Optionally test reset-password endpoint with invalid or expired token for error handling (POST /auth/reset-password)\n        reset_pwd_url = f\"{BASE_URL}/auth/reset-password\"\n        reset_payload = {\n            \"token\": \"invalid-or-expired-token\",\n            \"password\": \"newPassword1234!\"\n        }\n        reset_resp = session.post(reset_pwd_url, json=reset_payload, headers=login_headers, timeout=TIMEOUT)\n        # Expect failure due to token invalid\n        assert reset_resp.status_code in (400, 401), \"Reset password with invalid token should fail\"\n        reset_data = reset_resp.json()\n        # Error message should be clear\n        error_message = reset_data.get(\"error\") or reset_data.get(\"message\") or \"\"\n        assert \"invalid\" in error_message.lower() or \"expired\" in error_message.lower(), \"Clear error message expected for invalid token\"\n\n        # 4. Logout (POST /auth/logout)\n        logout_url = f\"{BASE_URL}/auth/logout\"\n        logout_resp = session.post(logout_url, timeout=TIMEOUT)\n        assert logout_resp.status_code == 200, f\"Logout failed: {logout_resp.text}\"\n        logout_data = logout_resp.json()\n        # Expect logged out or success message\n        assert logout_data.get(\"message\") or logout_data.get(\"success\") or \"logged out\" in str(logout_data).lower(), \"Logout response did not confirm success\"\n\n        # 5. Access protected route after logout should fail (GET /auth/verify)\n        post_logout_verify_resp = session.get(verify_url, timeout=TIMEOUT)\n        # Should return 401 Unauthorized or 403 Forbidden\n        assert post_logout_verify_resp.status_code in (401,403), \"Token verification should fail after logout\"\n        post_logout_data = post_logout_verify_resp.json()\n        error_msg = post_logout_data.get(\"error\") or post_logout_data.get(\"message\") or \"\"\n        assert error_msg, \"Error message expected after logout token verification fail\"\n\n    finally:\n        session.close()\n\ntest_admin_authentication_and_authorization()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 85, in <module>\n  File \"<string>\", line 33, in test_admin_authentication_and_authorization\nAssertionError: Token verification failed: \n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-19T19:00:46.450Z",
    "modified": "2026-01-19T19:02:29.417Z"
  },
  {
    "projectId": "6432887a-63b1-493b-b972-08963b570a3b",
    "testId": "e2c06f6d-d511-4d25-89ca-74cee1a92d83",
    "userId": "344844a8-1021-7022-adb9-65ed4dd64f25",
    "title": "TC004-patient management crud operations",
    "description": "Test the patient management APIs for creating, reading, updating, and deleting patient records. Validate phone number uniqueness and proper data validation.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:3000/api\"\nAUTH = HTTPBasicAuth(\"maxim.degtiarev.dev@gmail.com\", \"admin1234\")\nTIMEOUT = 30\n\ndef test_patient_management_crud_operations():\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\",\n    }\n\n    # Patient data for creation\n    patient_data = {\n        \"firstName\": \"Test\",\n        \"lastName\": \"Patient\",\n        \"phoneNumber\": \"5551234567\",\n        \"email\": \"test.patient@example.com\",\n        \"birthDate\": \"1980-05-15\",\n        \"address\": \"123 Main Street\",\n        \"notes\": \"Initial test patient\"\n    }\n\n    created_patient_id = None\n\n    try:\n        # 1. CREATE patient\n        response = requests.post(\n            f\"{BASE_URL}/patients\",\n            json=patient_data,\n            headers=headers,\n            auth=AUTH,\n            timeout=TIMEOUT\n        )\n        assert response.status_code in (200, 201), f\"Expected 200 or 201 Created, got {response.status_code}\"\n        created_patient = response.json()\n        created_patient_id = created_patient.get(\"id\") or created_patient.get(\"patientId\") or created_patient.get(\"_id\")\n        assert created_patient_id is not None, \"Created patient ID not returned\"\n\n        # Validate returned fields are at root level (not nested)\n        for field in ['firstName', 'lastName', 'phoneNumber', 'email', 'birthDate']:\n            assert field in created_patient, f\"Field {field} missing in created patient response\"\n\n        # 2. READ patient by ID\n        response = requests.get(\n            f\"{BASE_URL}/patients/{created_patient_id}\",\n            headers=headers,\n            auth=AUTH,\n            timeout=TIMEOUT\n        )\n        assert response.status_code == 200, f\"Expected 200 OK on read, got {response.status_code}\"\n        fetched_patient = response.json()\n        assert fetched_patient.get(\"id\") == created_patient_id or fetched_patient.get(\"patientId\") == created_patient_id, \"Patient ID mismatch on read\"\n        for field in ['firstName', 'lastName', 'phoneNumber', 'email', 'birthDate']:\n            assert field in fetched_patient, f\"Field {field} missing in fetched patient\"\n        assert fetched_patient[\"phoneNumber\"] == patient_data[\"phoneNumber\"], \"Phone number mismatch\"\n\n        # 3. UPDATE patient\n        updated_data = {\n            \"phoneNumber\": \"5557654321\",\n            \"notes\": \"Updated note for testing\"\n        }\n        response = requests.put(\n            f\"{BASE_URL}/patients/{created_patient_id}\",\n            json=updated_data,\n            headers=headers,\n            auth=AUTH,\n            timeout=TIMEOUT\n        )\n        assert response.status_code == 200, f\"Expected 200 OK on update, got {response.status_code}\"\n        updated_patient = response.json()\n        assert updated_patient[\"phoneNumber\"] == updated_data[\"phoneNumber\"], \"Phone number not updated\"\n        assert updated_patient.get(\"notes\") == updated_data[\"notes\"], \"Notes not updated\"\n\n        # 4. Validate phone number uniqueness - try to create another patient with same phone number should fail\n        duplicate_patient_data = {\n            \"firstName\": \"Duplicate\",\n            \"lastName\": \"User\",\n            \"phoneNumber\": updated_data[\"phoneNumber\"],  # Same phone number as existing patient\n            \"email\": \"duplicate@example.com\",\n            \"birthDate\": \"1990-01-01\"\n        }\n        response = requests.post(\n            f\"{BASE_URL}/patients\",\n            json=duplicate_patient_data,\n            headers=headers,\n            auth=AUTH,\n            timeout=TIMEOUT\n        )\n        assert response.status_code in (400, 409), f\"Expected 400 or 409 on duplicate phone number, got {response.status_code}\"\n        error_response = response.json()\n        assert \"phone\" in str(error_response).lower() or \"unique\" in str(error_response).lower(), \"Expected phone uniqueness error message\"\n\n        # 5. Validate data validation for required fields - try creating patient without required field firstName\n        invalid_patient_data = {\n            \"lastName\": \"NoFirstName\",\n            \"phoneNumber\": \"5559999999\",\n            \"email\": \"nofirst@example.com\",\n            \"birthDate\": \"1985-07-20\"\n        }\n        response = requests.post(\n            f\"{BASE_URL}/patients\",\n            json=invalid_patient_data,\n            headers=headers,\n            auth=AUTH,\n            timeout=TIMEOUT\n        )\n        assert response.status_code == 400, f\"Expected 400 Bad Request on missing required field, got {response.status_code}\"\n        validation_error = response.json()\n        error_messages = str(validation_error).lower()\n        assert (\"firstName\" in error_messages or \"firstname\" in error_messages or \"required\" in error_messages), \"Expected error about missing firstName field\"\n\n    finally:\n        # CLEANUP - DELETE the created patient if exists\n        if created_patient_id:\n            try:\n                del_response = requests.delete(\n                    f\"{BASE_URL}/patients/{created_patient_id}\",\n                    headers=headers,\n                    auth=AUTH,\n                    timeout=TIMEOUT\n                )\n                assert del_response.status_code in (200, 204), f\"Expected 200 or 204 on delete, got {del_response.status_code}\"\n            except Exception:\n                pass\n\n\ntest_patient_management_crud_operations()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 129, in <module>\n  File \"<string>\", line 43, in test_patient_management_crud_operations\nAssertionError: Field firstName missing in created patient response\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-19T19:00:46.456Z",
    "modified": "2026-01-19T19:02:29.423Z"
  },
  {
    "projectId": "6432887a-63b1-493b-b972-08963b570a3b",
    "testId": "2721a04b-9424-4aac-8446-9c7fbd9f152f",
    "userId": "344844a8-1021-7022-adb9-65ed4dd64f25",
    "title": "TC005-admin panel appointment and schedule management",
    "description": "Verify the admin panel APIs for managing appointments, work schedules, and system configurations. Ensure only authenticated admin users can access and modify data.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\nimport json\n\nBASE_URL = \"http://localhost:3000/api\"\nAUTH = HTTPBasicAuth(\"maxim.degtiarev.dev@gmail.com\", \"admin1234\")\nHEADERS = {\n    \"Content-Type\": \"application/json\",\n    \"Accept\": \"application/json\",\n}\nTIMEOUT = 30\n\ndef test_admin_panel_appointment_and_schedule_management():\n    # Authenticate and get session cookie by making an initial request to a protected endpoint\n    session = requests.Session()\n    session.auth = AUTH\n    session.headers.update(HEADERS)\n\n    # Step 1: Verify access to appointments list (GET /appointments)\n    try:\n        resp = session.get(f\"{BASE_URL}/appointments\", timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Expected 200 OK, got {resp.status_code}\"\n        resp_json = resp.json()\n        # We expect the response to be an object with a field containing a list of appointments\n        # Check common fields 'appointments' or 'data' for the list\n        if isinstance(resp_json, dict):\n            if \"appointments\" in resp_json:\n                appointments = resp_json[\"appointments\"]\n            elif \"data\" in resp_json:\n                appointments = resp_json[\"data\"]\n            else:\n                # Fallback: Find first list in values\n                appointments = next((v for v in resp_json.values() if isinstance(v, list)), None)\n            assert isinstance(appointments, list), \"Appointments response should contain a list\"\n        else:\n            assert False, \"Appointments response is not a dict\"\n    except Exception as e:\n        assert False, f\"Failed to get appointments: {e}\"\n\n    # Step 2: Create a new appointment (POST /appointments/create)\n    appointment_data = {\n        \"patient_name\": \"Test Patient\",\n        \"date\": \"2026-01-20\",\n        \"time\": \"10:00\",\n        \"visit_type\": \"Consulta\",\n        \"consult_type\": \"Primera vez\",\n        \"practice_type\": \"Dermatolog√≠a\",\n        \"health_insurance\": \"BasicPlan\",\n        \"notes\": \"Test appointment for automation\"\n    }\n    appointment_id = None\n    try:\n        resp = session.post(f\"{BASE_URL}/appointments/create\", data=json.dumps(appointment_data), timeout=TIMEOUT)\n        assert resp.status_code in (200,201), f\"Expected 200 or 201 Created, got {resp.status_code}\"\n        resp_json = resp.json()\n        # The appointment ID could be in 'id' or 'appointmentId' due to field name flexibility\n        appointment_id = resp_json.get(\"id\") or resp_json.get(\"appointmentId\")\n        assert appointment_id is not None, \"Created appointment missing id\"\n    except Exception as e:\n        assert False, f\"Failed to create appointment: {e}\"\n\n    # Step 3: Update the appointment (PUT /appointments/{id})\n    if appointment_id:\n        updated_data = {\n            \"notes\": \"Updated note - verified by automated test\",\n            \"visit_type\": \"Consulta\",\n            \"consult_type\": \"Seguimiento\"\n        }\n        try:\n            resp = session.put(f\"{BASE_URL}/appointments/{appointment_id}\", data=json.dumps(updated_data), timeout=TIMEOUT)\n            assert resp.status_code == 200, f\"Expected 200 OK on update, got {resp.status_code}\"\n            updated_resp = resp.json()\n            # Confirm updated fields returned reflect changes, checking snake_case or camelCase variants\n            notes = updated_resp.get(\"notes\") or updated_resp.get(\"Notes\")\n            visit_type = updated_resp.get(\"visit_type\") or updated_resp.get(\"visitType\")\n            consult_type = updated_resp.get(\"consult_type\") or updated_resp.get(\"consultType\")\n            assert notes == updated_data[\"notes\"], \"Appointment notes not updated correctly\"\n            assert visit_type == updated_data[\"visit_type\"], \"Appointment visit_type not updated correctly\"\n            assert consult_type == updated_data[\"consult_type\"], \"Appointment consult_type not updated correctly\"\n        except Exception as e:\n            assert False, f\"Failed to update appointment: {e}\"\n\n    # Step 4: Retrieve work schedule (GET /work-schedule)\n    try:\n        resp = session.get(f\"{BASE_URL}/work-schedule\", timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Expected 200 OK for work schedule, got {resp.status_code}\"\n        work_schedule = resp.json()\n        assert isinstance(work_schedule, list), \"Work schedule should be a list\"\n    except Exception as e:\n        assert False, f\"Failed to get work schedule: {e}\"\n\n    # Step 5: Create a work schedule entry (POST /work-schedule)\n    work_schedule_data = {\n        \"day\": \"Monday\",\n        \"start_time\": \"09:00\",\n        \"end_time\": \"17:00\",\n        \"active\": True\n    }\n    work_schedule_id = None\n    try:\n        resp = session.post(f\"{BASE_URL}/work-schedule\", data=json.dumps(work_schedule_data), timeout=TIMEOUT)\n        assert resp.status_code in (200,201), f\"Expected 200 or 201 when creating work schedule, got {resp.status_code}\"\n        ws_resp = resp.json()\n        work_schedule_id = ws_resp.get(\"id\") or ws_resp.get(\"workScheduleId\")\n        assert work_schedule_id is not None, \"Created work schedule missing id\"\n    except Exception as e:\n        assert False, f\"Failed to create work schedule: {e}\"\n\n    # Step 6: Update the created work schedule (PUT /work-schedule/{id})\n    if work_schedule_id:\n        updated_ws_data = {\n            \"end_time\": \"18:00\",\n            \"active\": False\n        }\n        try:\n            resp = session.put(f\"{BASE_URL}/work-schedule/{work_schedule_id}\", data=json.dumps(updated_ws_data), timeout=TIMEOUT)\n            assert resp.status_code == 200, f\"Expected 200 OK on updating work schedule, got {resp.status_code}\"\n            updated_ws_resp = resp.json()\n            # Check updated fields (camelCase or snake_case)\n            end_time = updated_ws_resp.get(\"end_time\") or updated_ws_resp.get(\"endTime\")\n            active = updated_ws_resp.get(\"active\")\n            assert end_time == updated_ws_data[\"end_time\"], \"Work schedule end_time not updated correctly\"\n            assert active == updated_ws_data[\"active\"], \"Work schedule active flag not updated correctly\"\n        except Exception as e:\n            assert False, f\"Failed to update work schedule: {e}\"\n\n    # Step 7: Retrieve system configurations (GET /config)\n    try:\n        resp = session.get(f\"{BASE_URL}/config\", timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Expected 200 OK for system configurations, got {resp.status_code}\"\n        config = resp.json()\n        assert isinstance(config, dict), \"System config response should be a dict\"\n    except Exception as e:\n        assert False, f\"Failed to get system configurations: {e}\"\n\n    # Step 8: Modify system configuration (PUT /config)\n    updated_config_data = {\n        \"settingA\": True,\n        \"maxAppointmentsPerDay\": 15\n    }\n    try:\n        resp = session.put(f\"{BASE_URL}/config\", data=json.dumps(updated_config_data), timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Expected 200 OK when updating config, got {resp.status_code}\"\n        config_updated_resp = resp.json()\n        # Check updates, accommodate camelCase or snake_case\n        setting_a_val = config_updated_resp.get(\"settingA\") or config_updated_resp.get(\"setting_a\")\n        max_appt_val = config_updated_resp.get(\"maxAppointmentsPerDay\") or config_updated_resp.get(\"max_appointments_per_day\")\n        assert setting_a_val == updated_config_data[\"settingA\"], \"Config settingA not updated\"\n        assert max_appt_val == updated_config_data[\"maxAppointmentsPerDay\"], \"Config maxAppointmentsPerDay not updated\"\n    except Exception as e:\n        assert False, f\"Failed to update system configuration: {e}\"\n\n    # Step 9: Test unauthorized access without auth (cookie/session)\n    try:\n        unauth_resp = requests.get(f\"{BASE_URL}/appointments\", timeout=TIMEOUT)\n        # Should fail: expecting 401 Unauthorized or 403 Forbidden\n        assert unauth_resp.status_code in (401,403), \\\n            f\"Expected unauthorized status for no auth, got {unauth_resp.status_code}\"\n    except Exception as e:\n        assert False, f\"Failed to verify unauthorized access handling: {e}\"\n\n    # Cleanup: Delete created appointment and work schedule if exist\n    try:\n        if appointment_id:\n            del_resp = session.delete(f\"{BASE_URL}/appointments/{appointment_id}\", timeout=TIMEOUT)\n            assert del_resp.status_code in (200,204), f\"Failed to delete appointment, got {del_resp.status_code}\"\n    except Exception:\n        pass\n\n    try:\n        if work_schedule_id:\n            del_ws_resp = session.delete(f\"{BASE_URL}/work-schedule/{work_schedule_id}\", timeout=TIMEOUT)\n            assert del_ws_resp.status_code in (200,204), f\"Failed to delete work schedule, got {del_ws_resp.status_code}\"\n    except Exception:\n        pass\n\ntest_admin_panel_appointment_and_schedule_management()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 54, in test_admin_panel_appointment_and_schedule_management\nAssertionError: Expected 200 or 201 Created, got 400\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 177, in <module>\n  File \"<string>\", line 60, in test_admin_panel_appointment_and_schedule_management\nAssertionError: Failed to create appointment: Expected 200 or 201 Created, got 400\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-19T19:00:46.461Z",
    "modified": "2026-01-19T19:03:18.752Z"
  },
  {
    "projectId": "6432887a-63b1-493b-b972-08963b570a3b",
    "testId": "73ff6261-9f19-4579-bb78-a4657b2ff04c",
    "userId": "344844a8-1021-7022-adb9-65ed4dd64f25",
    "title": "TC006-appointment cancellation with token verification",
    "description": "Test the appointment cancellation APIs to ensure secure cancellation using token-based verification and enforcement of the 24-hour advance cancellation policy.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\nfrom datetime import datetime, timedelta\nimport traceback\n\nBASE_URL = \"http://localhost:3000/api\"\nAUTH = HTTPBasicAuth(\"maxim.degtiarev.dev@gmail.com\", \"admin1234\")\nHEADERS = {\"Content-Type\": \"application/json\"}\nTIMEOUT = 30\n\ndef test_appointment_cancellation_with_token_verification():\n    appointment = None\n    cancellation_token = None\n    \n    try:\n        # Step 1: Create a patient to associate with appointment\n        patient_data = {\n            \"first_name\": \"Test\",\n            \"last_name\": \"Patient\",\n            \"email\": f\"testpatient_{datetime.utcnow().timestamp()}@example.com\",\n            \"phone\": f\"555{int(datetime.utcnow().timestamp()) % 10000000:07d}\"\n        }\n        patient_resp = requests.post(\n            f\"{BASE_URL}/patients\",\n            auth=AUTH,\n            headers=HEADERS,\n            json=patient_data,\n            timeout=TIMEOUT,\n        )\n        assert patient_resp.status_code == 201, f\"Failed to create patient: {patient_resp.text}\"\n        patient = patient_resp.json()\n        patient_id = patient.get(\"id\") or patient.get(\"patient_id\") or patient.get(\"id\".lower())\n\n        # Step 2: Retrieve visit types (should be array)\n        visit_types_resp = requests.get(f\"{BASE_URL}/visit-types\", auth=AUTH, timeout=TIMEOUT)\n        assert visit_types_resp.status_code == 200, \"Failed to get visit types\"\n        visit_types = visit_types_resp.json()\n        assert isinstance(visit_types, list) and len(visit_types) > 0, \"Visit types response invalid\"\n\n        # Step 3: Retrieve consult types (should be array)\n        consult_types_resp = requests.get(f\"{BASE_URL}/consult-types\", auth=AUTH, timeout=TIMEOUT)\n        assert consult_types_resp.status_code == 200, \"Failed to get consult types\"\n        consult_types = consult_types_resp.json()\n        assert isinstance(consult_types, list) and len(consult_types) > 0, \"Consult types response invalid\"\n\n        # Step 4: Retrieve practice types (should be array, required for appointment creation)\n        practice_types_resp = requests.get(f\"{BASE_URL}/practice-types\", auth=AUTH, timeout=TIMEOUT)\n        assert practice_types_resp.status_code == 200, \"Failed to get practice types\"\n        practice_types = practice_types_resp.json()\n        assert isinstance(practice_types, list) and len(practice_types) > 0, \"Practice types response invalid\"\n\n        # Step 5: Retrieve health insurance options (assumed needed)\n        health_ins_resp = requests.get(f\"{BASE_URL}/health-insurance\", auth=AUTH, timeout=TIMEOUT)\n        assert health_ins_resp.status_code == 200, \"Failed to get health insurance options\"\n        health_ins_options = health_ins_resp.json()\n        assert isinstance(health_ins_options, list) and len(health_ins_options) > 0, \"Health insurance response invalid\"\n\n        # Step 6: Schedule an appointment more than 24h in the future to meet cancellation policy\n        future_date = (datetime.utcnow() + timedelta(days=2)).date().isoformat()\n        # For simplicity, pick first visit type, consult type, practice type, and health insurance\n        appointment_payload = {\n            \"patient_id\": patient_id,\n            \"date\": future_date,\n            \"time\": \"10:00\",  # Assuming API accepts this time format and slot is available\n            \"visit_type\": visit_types[0].get(\"id\") or visit_types[0].get(\"visit_type_id\") or visit_types[0].get(\"id\".lower()),\n            \"consult_type\": consult_types[0].get(\"id\") or consult_types[0].get(\"consult_type_id\") or consult_types[0].get(\"id\".lower()),\n            \"practice_type\": practice_types[0].get(\"id\") or practice_types[0].get(\"practice_type_id\") or practice_types[0].get(\"id\".lower()),\n            \"health_insurance\": health_ins_options[0].get(\"id\") or health_ins_options[0].get(\"health_insurance_id\") or health_ins_options[0].get(\"id\".lower())\n        }\n\n        appointment_resp = requests.post(\n            f\"{BASE_URL}/appointments\",\n            auth=AUTH,\n            headers=HEADERS,\n            json=appointment_payload,\n            timeout=TIMEOUT,\n        )\n        assert appointment_resp.status_code == 201, f\"Failed to create appointment: {appointment_resp.text}\"\n        appointment = appointment_resp.json()\n        appointment_id = appointment.get(\"id\") or appointment.get(\"appointment_id\") or appointment.get(\"id\".lower())\n\n        # Step 7: Request cancellation token generation or retrieve token if returned on creation\n        # Assuming there's an endpoint like /cancel-appointment/verify that verifies appointment and provides token\n        verify_resp = requests.post(\n            f\"{BASE_URL}/cancel-appointment/verify\",\n            auth=AUTH,\n            headers=HEADERS,\n            json={\"appointment_id\": appointment_id},\n            timeout=TIMEOUT,\n        )\n        assert verify_resp.status_code == 200, f\"Cancellation token verification failed: {verify_resp.text}\"\n        verify_data = verify_resp.json()\n        cancellation_token = verify_data.get(\"token\") or verify_data.get(\"cancellation_token\")\n\n        assert cancellation_token is not None and isinstance(cancellation_token, str), \"Cancellation token missing or invalid\"\n\n        # Step 8: Attempt cancellation using the token (should succeed)\n        cancel_resp = requests.post(\n            f\"{BASE_URL}/cancel-appointment\",\n            auth=AUTH,\n            headers=HEADERS,\n            json={\"token\": cancellation_token},\n            timeout=TIMEOUT,\n        )\n        assert cancel_resp.status_code == 200, f\"Appointment cancellation failed: {cancel_resp.text}\"\n        cancel_result = cancel_resp.json()\n        assert cancel_result.get(\"status\") == \"cancelled\" or \"cancel\" in str(cancel_result).lower(), \"Cancellation not confirmed in response\"\n\n        # Step 9: Attempt cancellation with the same token again (should fail, token expired or invalid)\n        cancel_resp_repeat = requests.post(\n            f\"{BASE_URL}/cancel-appointment\",\n            auth=AUTH,\n            headers=HEADERS,\n            json={\"token\": cancellation_token},\n            timeout=TIMEOUT,\n        )\n        assert cancel_resp_repeat.status_code != 200, \"Cancellation repeated with same token should fail\"\n        error_msg = cancel_resp_repeat.json().get(\"error\") or cancel_resp_repeat.json().get(\"message\")\n        assert error_msg is not None and (\"invalid\" in error_msg.lower() or \"expired\" in error_msg.lower()), \"Proper error message not returned for reused token\"\n\n        # Step 10: Attempt cancellation less than 24h ahead (create appointment within 23h and try to cancel)\n        near_date_time = datetime.utcnow() + timedelta(hours=23)\n        near_date = near_date_time.date().isoformat()\n        near_time = near_date_time.strftime(\"%H:%M\")\n        appointment_payload_2 = {\n            \"patient_id\": patient_id,\n            \"date\": near_date,\n            \"time\": near_time,\n            \"visit_type\": visit_types[0].get(\"id\") or visit_types[0].get(\"visit_type_id\") or visit_types[0].get(\"id\".lower()),\n            \"consult_type\": consult_types[0].get(\"id\") or consult_types[0].get(\"consult_type_id\") or consult_types[0].get(\"id\".lower()),\n            \"practice_type\": practice_types[0].get(\"id\") or practice_types[0].get(\"practice_type_id\") or practice_types[0].get(\"id\".lower()),\n            \"health_insurance\": health_ins_options[0].get(\"id\") or health_ins_options[0].get(\"health_insurance_id\") or health_ins_options[0].get(\"id\".lower())\n        }\n        appointment_resp_2 = requests.post(\n            f\"{BASE_URL}/appointments\",\n            auth=AUTH,\n            headers=HEADERS,\n            json=appointment_payload_2,\n            timeout=TIMEOUT,\n        )\n        assert appointment_resp_2.status_code == 201, f\"Failed to create appointment for 24h policy test: {appointment_resp_2.text}\"\n        appointment_2 = appointment_resp_2.json()\n        appointment_id_2 = appointment_2.get(\"id\") or appointment_2.get(\"appointment_id\") or appointment_2.get(\"id\".lower())\n\n        verify_resp_2 = requests.post(\n            f\"{BASE_URL}/cancel-appointment/verify\",\n            auth=AUTH,\n            headers=HEADERS,\n            json={\"appointment_id\": appointment_id_2},\n            timeout=TIMEOUT,\n        )\n        assert verify_resp_2.status_code == 200, f\"Cancellation token verification failed for near appointment: {verify_resp_2.text}\"\n        cancellation_token_2 = verify_resp_2.json().get(\"token\") or verify_resp_2.json().get(\"cancellation_token\")\n        assert cancellation_token_2 is not None and isinstance(cancellation_token_2, str), \"Cancellation token missing or invalid for near appointment\"\n\n        # Now try to cancel appointment less than 24h ahead - should fail due to 24h policy\n        cancel_resp_2 = requests.post(\n            f\"{BASE_URL}/cancel-appointment\",\n            auth=AUTH,\n            headers=HEADERS,\n            json={\"token\": cancellation_token_2},\n            timeout=TIMEOUT,\n        )\n        assert cancel_resp_2.status_code == 400 or cancel_resp_2.status_code == 403, \"Cancellation within 24h should be forbidden\"\n        error_msg_2 = cancel_resp_2.json().get(\"error\") or cancel_resp_2.json().get(\"message\")\n        assert error_msg_2 is not None and (\"24 hour\" in error_msg_2.lower() or \"advance\" in error_msg_2.lower()), \"Proper error message not returned for 24h policy violation\"\n\n    except Exception as e:\n        traceback.print_exc()\n        raise e\n\n    finally:\n        # Cleanup: delete the appointments and patient created\n        try:\n            if appointment and appointment.get(\"id\"):\n                requests.delete(f\"{BASE_URL}/appointments/{appointment['id']}\", auth=AUTH, timeout=TIMEOUT)\n        except:\n            pass\n        try:\n            if 'appointment_2' in locals() and appointment_2 and appointment_2.get(\"id\"):\n                requests.delete(f\"{BASE_URL}/appointments/{appointment_2['id']}\", auth=AUTH, timeout=TIMEOUT)\n        except:\n            pass\n        try:\n            if patient and patient.get(\"id\"):\n                requests.delete(f\"{BASE_URL}/patients/{patient['id']}\", auth=AUTH, timeout=TIMEOUT)\n        except:\n            pass\n\ntest_appointment_cancellation_with_token_verification()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 190, in <module>\n  File \"<string>\", line 170, in test_appointment_cancellation_with_token_verification\n  File \"<string>\", line 48, in test_appointment_cancellation_with_token_verification\nAssertionError: Failed to get practice types\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-19T19:00:46.467Z",
    "modified": "2026-01-19T19:03:16.322Z"
  },
  {
    "projectId": "6432887a-63b1-493b-b972-08963b570a3b",
    "testId": "3520843b-a5cc-45aa-ad9e-c8519a72ba2a",
    "userId": "344844a8-1021-7022-adb9-65ed4dd64f25",
    "title": "TC007-appointment confirmation details",
    "description": "Verify the appointment confirmation API/page displays accurate appointment details and cancellation instructions to the patient.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\nimport uuid\nimport datetime\n\nBASE_URL = \"http://localhost:3000/api\"\nAUTH = HTTPBasicAuth(\"maxim.degtiarev.dev@gmail.com\", \"admin1234\")\nTIMEOUT = 30\n\ndef test_appointment_confirmation_details():\n    # Step 1: Create a patient to book an appointment for\n    patient_payload = {\n        \"firstName\": \"Test\",\n        \"lastName\": \"Patient\",\n        \"email\": f\"test.patient.{uuid.uuid4()}@example.com\",\n        \"phone\": f\"+1555{uuid.uuid4().int % 10000000:07d}\"\n    }\n    patient_id = None\n    appointment_id = None\n    try:\n        # Create patient\n        r_patient = requests.post(\n            f\"{BASE_URL}/patients\",\n            json=patient_payload,\n            auth=AUTH,\n            timeout=TIMEOUT\n        )\n        assert r_patient.status_code == 201, f\"Patient creation failed: {r_patient.text}\"\n        patient_data = r_patient.json()\n        patient_id = patient_data.get(\"id\") or patient_data.get(\"patientId\")\n        assert patient_id is not None, \"Patient ID missing in creation response\"\n\n        # Step 2: Retrieve visit types and consult types (they return arrays)\n        r_visit_types = requests.get(f\"{BASE_URL}/visit-types\", auth=AUTH, timeout=TIMEOUT)\n        assert r_visit_types.status_code == 200, f\"Failed to get visit types: {r_visit_types.text}\"\n        visit_types = r_visit_types.json()\n        assert isinstance(visit_types, list) and len(visit_types) > 0, \"Visit types should be non-empty list\"\n\n        r_consult_types = requests.get(f\"{BASE_URL}/consult-types\", auth=AUTH, timeout=TIMEOUT)\n        assert r_consult_types.status_code == 200, f\"Failed to get consult types: {r_consult_types.text}\"\n        consult_types = r_consult_types.json()\n        assert isinstance(consult_types, list) and len(consult_types) > 0, \"Consult types should be non-empty list\"\n\n        # Step 3: Retrieve health insurance options (required for appointment)\n        r_insurances = requests.get(f\"{BASE_URL}/health-insurance\", auth=AUTH, timeout=TIMEOUT)\n        assert r_insurances.status_code == 200, f\"Failed to get health insurances: {r_insurances.text}\"\n        insurances = r_insurances.json()\n        assert isinstance(insurances, list) and len(insurances) > 0, \"Health insurances should be non-empty list\"\n\n        # Step 4: Determine an appointment date (next weekday, skipping weekends)\n        appointment_date_obj = datetime.datetime.utcnow().date() + datetime.timedelta(days=1)\n        while appointment_date_obj.weekday() >= 5:  # 5=Saturday, 6=Sunday\n            appointment_date_obj += datetime.timedelta(days=1)\n        appointment_date = appointment_date_obj.isoformat()\n\n        # Step 5: Get available times for that date\n        r_available_times = requests.get(f\"{BASE_URL}/available-times/{appointment_date}\", auth=AUTH, timeout=TIMEOUT)\n        assert r_available_times.status_code == 200, f\"Failed to get available times: {r_available_times.text}\"\n        available_times = r_available_times.json()\n        assert isinstance(available_times, list) and len(available_times) > 0, \"Available times should be non-empty list\"\n\n        appointment_time = available_times[0].get(\"time\") or available_times[0].get(\"time_slot\") or available_times[0]\n        assert appointment_time is not None, \"Could not determine an available time slot\"\n\n        # Step 6: Create the appointment using obtained ids and time\n        appointment_payload = {\n            \"patientId\": patient_id,\n            \"date\": appointment_date,\n            \"time\": appointment_time,\n            \"visitType\": visit_types[0].get(\"id\") or visit_types[0].get(\"visit_type_id\") or visit_types[0],\n            \"consultType\": consult_types[0].get(\"id\") or consult_types[0].get(\"consult_type_id\") or consult_types[0],\n            \"healthInsuranceId\": insurances[0].get(\"id\") or insurances[0].get(\"health_insurance_id\") or insurances[0]\n        }\n\n        r_appointment = requests.post(\n            f\"{BASE_URL}/appointments\",\n            json=appointment_payload,\n            auth=AUTH,\n            timeout=TIMEOUT\n        )\n        assert r_appointment.status_code == 201, f\"Appointment creation failed: {r_appointment.text}\"\n        appointment_data = r_appointment.json()\n        appointment_id = appointment_data.get(\"id\") or appointment_data.get(\"appointmentId\")\n        assert appointment_id is not None, \"Appointment ID missing in creation response\"\n\n        # Step 7: Retrieve appointment confirmation details\n        r_confirmation = requests.get(\n            f\"{BASE_URL}/appointments/{appointment_id}/confirmation\",\n            auth=AUTH,\n            timeout=TIMEOUT\n        )\n        assert r_confirmation.status_code == 200, f\"Failed to get appointment confirmation: {r_confirmation.text}\"\n        confirmation_data = r_confirmation.json()\n\n        # Validation: Check key appointment details present and matching\n        # Patient info at root level (per fix #1)\n        patient_info_keys = [\"firstName\", \"lastName\", \"email\", \"phone\"]\n        for key in patient_info_keys:\n            assert key in confirmation_data, f\"Patient field '{key}' missing in confirmation response\"\n            assert confirmation_data[key] == patient_payload[key], f\"Mismatch in patient field '{key}'\"\n\n        # Confirm date and time correctness (flexible field names)\n        date_field = confirmation_data.get(\"date\") or confirmation_data.get(\"appointment_date\")\n        time_field = confirmation_data.get(\"time\") or confirmation_data.get(\"appointment_time\")\n        assert date_field == appointment_date, \"Appointment date mismatch in confirmation\"\n        assert time_field == appointment_time, \"Appointment time mismatch in confirmation\"\n\n        # Visit and consult types should be arrays with elements (per fix #1)\n        visit_types_field = confirmation_data.get(\"visitTypes\") or confirmation_data.get(\"visit_types\")\n        assert isinstance(visit_types_field, list) and len(visit_types_field) > 0, \"Visit types missing or invalid\"\n\n        consult_types_field = confirmation_data.get(\"consultTypes\") or confirmation_data.get(\"consult_types\")\n        assert isinstance(consult_types_field, list) and len(consult_types_field) > 0, \"Consult types missing or invalid\"\n\n        # Cancellation instructions presence (an important part)\n        cancellation_instructions = confirmation_data.get(\"cancellationInstructions\") or confirmation_data.get(\"cancellation_instructions\")\n        cancellation_link = confirmation_data.get(\"cancellationLink\") or confirmation_data.get(\"cancellation_link\")\n        assert cancellation_instructions and isinstance(cancellation_instructions, str), \"Cancellation instructions missing or invalid\"\n        assert cancellation_link and isinstance(cancellation_link, str) and cancellation_link.startswith(\"http\"), \"Cancellation link missing or invalid\"\n\n    finally:\n        # Clean up: delete the created appointment if exists\n        if appointment_id:\n            try:\n                r_del_appointment = requests.delete(\n                    f\"{BASE_URL}/appointments/{appointment_id}\",\n                    auth=AUTH,\n                    timeout=TIMEOUT\n                )\n                assert r_del_appointment.status_code in (200, 204), f\"Failed to delete appointment: {r_del_appointment.text}\"\n            except Exception as e:\n                print(f\"Cleanup failed for appointment: {e}\")\n\n        # Clean up: delete the created patient if exists\n        if patient_id:\n            try:\n                r_del_patient = requests.delete(\n                    f\"{BASE_URL}/patients/{patient_id}\",\n                    auth=AUTH,\n                    timeout=TIMEOUT\n                )\n                assert r_del_patient.status_code in (200, 204), f\"Failed to delete patient: {r_del_patient.text}\"\n            except Exception as e:\n                print(f\"Cleanup failed for patient: {e}\")\n\ntest_appointment_confirmation_details()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 146, in <module>\n  File \"<string>\", line 60, in test_appointment_confirmation_details\nAssertionError: Available times should be non-empty list\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-19T19:00:46.473Z",
    "modified": "2026-01-19T19:03:18.748Z"
  },
  {
    "projectId": "6432887a-63b1-493b-b972-08963b570a3b",
    "testId": "dcc25926-485e-4f70-a749-8806279c0709",
    "userId": "344844a8-1021-7022-adb9-65ed4dd64f25",
    "title": "TC008-work schedule management",
    "description": "Test the work schedule management APIs for creating, updating, and retrieving the doctor's work schedule configurations.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000/api/work-schedule\"\nHEADERS = {\n    \"Content-Type\": \"application/json\",\n    \"Accept\": \"application/json\",\n}\nTIMEOUT = 30\n\ndef test_work_schedule_management():\n    created_schedule_id = None\n    try:\n        # Step 1: Create a new work schedule configuration\n        create_payload = {\n            \"doctor_id\": str(uuid.uuid4()),\n            \"work_days\": [\n                {\"day_of_week\": \"monday\", \"start_time\": \"09:00\", \"end_time\": \"17:00\"},\n                {\"day_of_week\": \"tuesday\", \"start_time\": \"09:00\", \"end_time\": \"17:00\"},\n                {\"day_of_week\": \"wednesday\", \"start_time\": \"09:00\", \"end_time\": \"17:00\"},\n                {\"day_of_week\": \"thursday\", \"start_time\": \"09:00\", \"end_time\": \"17:00\"},\n                {\"day_of_week\": \"friday\", \"start_time\": \"09:00\", \"end_time\": \"17:00\"}\n            ],\n            \"consult_types\": [\"primera_vez\", \"seguimiento\"],\n            \"visit_types\": [\"consulta\", \"practica\"]\n        }\n        create_response = requests.post(\n            f\"{BASE_URL}\",\n            json=create_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert create_response.status_code == 201, f\"Failed to create work schedule: {create_response.text}\"\n        created_schedule = create_response.json()\n        assert \"id\" in created_schedule, \"Response missing 'id' on creation\"\n        created_schedule_id = created_schedule[\"id\"]\n\n        # Step 2: Retrieve the created work schedule by ID\n        get_response = requests.get(\n            f\"{BASE_URL}/{created_schedule_id}\",\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert get_response.status_code == 200, f\"Failed to get work schedule: {get_response.text}\"\n        retrieved_schedule = get_response.json()\n        assert retrieved_schedule[\"id\"] == created_schedule_id, \"Retrieved schedule id mismatch\"\n        assert \"work_days\" in retrieved_schedule and isinstance(retrieved_schedule[\"work_days\"], list), \"work_days missing or invalid\"\n        assert \"consult_types\" in retrieved_schedule and isinstance(retrieved_schedule[\"consult_types\"], list), \"consult_types missing or invalid\"\n        assert \"visit_types\" in retrieved_schedule and isinstance(retrieved_schedule[\"visit_types\"], list), \"visit_types missing or invalid\"\n\n        # Step 3: Update the work schedule configuration\n        update_payload = {\n            \"work_days\": [\n                {\"day_of_week\": \"monday\", \"start_time\": \"08:00\", \"end_time\": \"16:00\"},\n                {\"day_of_week\": \"tuesday\", \"start_time\": \"08:00\", \"end_time\": \"16:00\"},\n                {\"day_of_week\": \"wednesday\", \"start_time\": \"08:00\", \"end_time\": \"16:00\"},\n                {\"day_of_week\": \"thursday\", \"start_time\": \"08:00\", \"end_time\": \"16:00\"},\n                {\"day_of_week\": \"friday\", \"start_time\": \"08:00\", \"end_time\": \"16:00\"}\n            ],\n            \"consult_types\": [\"primera_vez\"],  # Changed to snake_case to follow create payload keys\n            \"visit_types\": [\"consulta\"]\n        }\n        update_response = requests.put(\n            f\"{BASE_URL}/{created_schedule_id}\",\n            json=update_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert update_response.status_code == 200, f\"Failed to update work schedule: {update_response.text}\"\n        updated_schedule = update_response.json()\n        assert updated_schedule[\"id\"] == created_schedule_id, \"Updated schedule id mismatch\"\n        assert updated_schedule.get(\"work_days\")[0][\"start_time\"] == \"08:00\", \"Update did not change work_days correctly\"\n        assert \"primera_vez\" in updated_schedule.get(\"consult_types\", []), \"Update did not change consult_types correctly\"\n        assert \"consulta\" in updated_schedule.get(\"visit_types\", []), \"Update did not change visit_types correctly\"\n\n        # Step 4: Verify the updated configuration by getting again\n        get_response_2 = requests.get(\n            f\"{BASE_URL}/{created_schedule_id}\",\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert get_response_2.status_code == 200, f\"Failed to get updated work schedule: {get_response_2.text}\"\n        retrieved_schedule_2 = get_response_2.json()\n        assert retrieved_schedule_2[\"id\"] == created_schedule_id, \"Retrieved schedule id mismatch after update\"\n        assert retrieved_schedule_2[\"work_days\"][0][\"start_time\"] == \"08:00\", \"work_days start_time not updated on retrieval\"\n        # Also check that response arrays for visit_types and consult_types are present and lists\n        assert isinstance(retrieved_schedule_2.get(\"visit_types\"), list), \"visit_types missing or not list after update\"\n        assert isinstance(retrieved_schedule_2.get(\"consult_types\"), list), \"consult_types missing or not list after update\"\n\n    finally:\n        # Clean up by deleting the created work schedule\n        if created_schedule_id:\n            delete_response = requests.delete(\n                f\"{BASE_URL}/{created_schedule_id}\",\n                headers=HEADERS,\n                timeout=TIMEOUT\n            )\n            assert delete_response.status_code in (200, 204), f\"Failed to delete work schedule: {delete_response.text}\"\n\ntest_work_schedule_management()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 100, in <module>\n  File \"<string>\", line 33, in test_work_schedule_management\nAssertionError: Failed to create work schedule: {\"error\":\"Missing required field: day_of_week\",\"required\":[\"day_of_week\"],\"optional\":[\"is_working_day\"]}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-19T19:00:46.478Z",
    "modified": "2026-01-19T19:03:20.678Z"
  },
  {
    "projectId": "6432887a-63b1-493b-b972-08963b570a3b",
    "testId": "10adf276-e6a0-4d87-82c4-20c4da227289",
    "userId": "344844a8-1021-7022-adb9-65ed4dd64f25",
    "title": "TC009-unavailable days and times management",
    "description": "Verify the APIs for marking specific dates and time slots as unavailable, ensuring these are excluded from available appointment times.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\nimport datetime\n\nBASE_URL = \"http://localhost:3000/api\"\nAUTH = HTTPBasicAuth(\"maxim.degtiarev.dev@gmail.com\", \"admin1234\")\nHEADERS = {\"Content-Type\": \"application/json\"}\nTIMEOUT = 30\n\ndef test_unavailable_days_and_times_management():\n    # Setup: define test unavailable day and time\n    unavailable_date = (datetime.date.today() + datetime.timedelta(days=10)).isoformat()  # 10 days from today\n    unavailable_time_start = \"14:00\"\n    unavailable_time_end = \"15:00\"\n    \n    # Create unavailable day (POST /unavailable-days)\n    unavailable_day_payload = {\"unavailable_date\": unavailable_date, \"reason\": \"Test unavailable day\"}\n    resp_day = requests.post(f\"{BASE_URL}/unavailable-days\", auth=AUTH, headers=HEADERS, json=unavailable_day_payload, timeout=TIMEOUT)\n    assert resp_day.status_code == 201, f\"Failed to create unavailable day: {resp_day.text}\"\n    created_unavailable_day = resp_day.json()\n    assert \"unavailable_date\" in created_unavailable_day and created_unavailable_day[\"unavailable_date\"] == unavailable_date\n    \n    # Create unavailable time slot (POST /unavailable-times)\n    unavailable_time_payload = {\n        \"unavailable_date\": unavailable_date,\n        \"timeRange\": {\"start\": unavailable_time_start, \"end\": unavailable_time_end},\n        \"reason\": \"Test unavailable time slot\"\n    }\n    resp_time = requests.post(f\"{BASE_URL}/unavailable-times\", auth=AUTH, headers=HEADERS, json=unavailable_time_payload, timeout=TIMEOUT)\n    assert resp_time.status_code == 201, f\"Failed to create unavailable time slot: {resp_time.text}\"\n    created_unavailable_time = resp_time.json()\n    assert created_unavailable_time.get(\"unavailable_date\") == unavailable_date\n    assert \"timeRange\" in created_unavailable_time\n    assert created_unavailable_time[\"timeRange\"][\"start\"] == unavailable_time_start\n    assert created_unavailable_time[\"timeRange\"][\"end\"] == unavailable_time_end\n\n    try:\n        # Verify unavailable day is listed (GET /unavailable-days/[date])\n        resp_check_day = requests.get(f\"{BASE_URL}/unavailable-days/{unavailable_date}\", auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n        assert resp_check_day.status_code == 200, f\"Unavailable day not found: {resp_check_day.text}\"\n        day_data = resp_check_day.json()\n        assert day_data.get(\"unavailable_date\") == unavailable_date\n\n        # Verify unavailable time is listed (GET /unavailable-times/[date])\n        resp_check_time = requests.get(f\"{BASE_URL}/unavailable-times/{unavailable_date}\", auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n        assert resp_check_time.status_code == 200, f\"Unavailable time not found: {resp_check_time.text}\"\n        times_data = resp_check_time.json()\n        assert isinstance(times_data, list), \"Unavailable times response should be a list\"\n        # Check that the created unavailable time slot is in the list\n        matched = any(\n            t.get(\"timeRange\", {}).get(\"start\") == unavailable_time_start and\n            t.get(\"timeRange\", {}).get(\"end\") == unavailable_time_end\n            for t in times_data\n        )\n        assert matched, \"Created unavailable time slot not found in the list\"\n\n        # Check that unavailable day and time exclude these from available times\n        resp_available = requests.get(f\"{BASE_URL}/available-times/{unavailable_date}\", auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n        assert resp_available.status_code == 200, f\"Failed to get available times: {resp_available.text}\"\n        available_times = resp_available.json()\n        # available_times expected to be list of time slots (strings or dicts)\n        for slot in available_times:\n            if isinstance(slot, dict) and \"time\" in slot:\n                time_str = slot[\"time\"]\n            elif isinstance(slot, str):\n                time_str = slot\n            else:\n                continue\n            # Assert that no slot is in the unavailable time range\n            slot_time = datetime.datetime.strptime(time_str, \"%H:%M\").time()\n            start_time = datetime.datetime.strptime(unavailable_time_start, \"%H:%M\").time()\n            end_time = datetime.datetime.strptime(unavailable_time_end, \"%H:%M\").time()\n            assert not (start_time <= slot_time < end_time), f\"Unavailable time slot {time_str} found in available times\"\n\n        # Also, if unavailable day is marked, the available times list should be empty or absent (depending on implementation)\n        # If available_times is empty list, accept, else accept no slots on that day except possibly empty list\n        assert isinstance(available_times, list), \"Available times response should be a list\"\n        assert len(available_times) == 0, \"Available times should be empty for an unavailable day\"\n\n    finally:\n        # Cleanup: delete created unavailable time slot(s)\n        # Attempt delete unavailable time slots for the date\n        resp_times_all = requests.get(f\"{BASE_URL}/unavailable-times/{unavailable_date}\", auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n        if resp_times_all.status_code == 200:\n            times_list = resp_times_all.json()\n            for tslot in times_list:\n                tslot_id = tslot.get(\"id\")\n                if not tslot_id:\n                    continue\n                del_resp = requests.delete(f\"{BASE_URL}/unavailable-times/{tslot_id}\", auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n                assert del_resp.status_code in (200, 204, 404)\n\n        # Delete unavailable day\n        del_day_resp = requests.delete(f\"{BASE_URL}/unavailable-days/{unavailable_date}\", auth=AUTH, headers=HEADERS, timeout=TIMEOUT)\n        assert del_day_resp.status_code in (200, 204, 404)\n\ntest_unavailable_days_and_times_management()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 97, in <module>\n  File \"<string>\", line 19, in test_unavailable_days_and_times_management\nAssertionError: Failed to create unavailable day: {\"error\":\"Internal server error\",\"details\":\"null value in column \\\"work_schedule_id\\\" of relation \\\"unavailable_days\\\" violates not-null constraint\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-19T19:00:46.491Z",
    "modified": "2026-01-19T19:03:43.800Z"
  },
  {
    "projectId": "6432887a-63b1-493b-b972-08963b570a3b",
    "testId": "faa033c4-064b-4e84-8a77-2edcf5886fc8",
    "userId": "344844a8-1021-7022-adb9-65ed4dd64f25",
    "title": "TC010-push notifications subscription and sending",
    "description": "Test the push notification APIs for subscribing, unsubscribing, and sending notifications to users, ensuring correct handling of subscription data and notification delivery.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000/api/push\"\nHEADERS = {\"Content-Type\": \"application/json\"}\nTIMEOUT = 30\n\ndef test_push_notifications_subscription_and_sending():\n    subscription_url = f\"{BASE_URL}/subscribe\"\n    unsubscribe_url = f\"{BASE_URL}/unsubscribe\"\n    send_url = f\"{BASE_URL}/send\"\n\n    # Corrected subscription payload wrapped in 'subscription' key as expected by API\n    subscription_payload = {\n        \"subscription\": {\n            \"endpoint\": \"https://fcm.googleapis.com/fcm/send/fake_endpoint_id\",\n            \"keys\": {\n                \"p256dh\": \"BOr_fake_p256dh_key\",\n                \"auth\": \"fake_auth_key\"\n            }\n        },\n        \"userId\": \"test-user-123\"\n    }\n\n    try:\n        # Subscribe to push notifications\n        resp_subscribe = requests.post(\n            subscription_url,\n            json=subscription_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert resp_subscribe.status_code in [200, 201], \\\n            f\"Subscribe response status {resp_subscribe.status_code}, body: {resp_subscribe.text}\"\n        resp_subscribe_data = resp_subscribe.json()\n        # Expect subscription id or confirmation\n        assert \"id\" in resp_subscribe_data or resp_subscribe_data.get(\"success\") is True, \\\n            f\"Unexpected subscribe response content: {resp_subscribe.text}\"\n\n        # Test sending notification to the subscribed user\n        # Using provided userId and a sample notification payload\n        send_payload = {\n            \"userId\": subscription_payload[\"userId\"],\n            \"title\": \"Test Notification\",\n            \"body\": \"This is a test push notification from automated tests.\",\n            \"data\": {\"test_case\": \"TC010\"}\n        }\n\n        resp_send = requests.post(\n            send_url,\n            json=send_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert resp_send.status_code == 200, f\"Send notification failed: {resp_send.text}\"\n        send_resp_data = resp_send.json()\n        # Expect success indicator\n        assert send_resp_data.get(\"success\") is True, f\"Notification send response unexpected: {resp_send.text}\"\n\n        # Unsubscribe from push notifications\n        resp_unsubscribe = requests.post(\n            unsubscribe_url,\n            json={\"endpoint\": subscription_payload[\"subscription\"][\"endpoint\"]},\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert resp_unsubscribe.status_code == 200, f\"Unsubscribe failed: {resp_unsubscribe.text}\"\n        unsubscribe_data = resp_unsubscribe.json()\n        assert unsubscribe_data.get(\"success\") is True, f\"Unsubscribe response unexpected: {resp_unsubscribe.text}\"\n\n        # Attempt sending notification after unsubscribe should fail or not send\n        resp_send_after_unsub = requests.post(\n            send_url,\n            json=send_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        # The server may respond with success but measures report no recipient,\n        # or respond with an error. Accept either 200 with success: false or 400+\n        if resp_send_after_unsub.status_code == 200:\n            data = resp_send_after_unsub.json()\n            assert not data.get(\"success\", True), \"Notification sent after unsubscription, unexpected.\"\n        else:\n            assert resp_send_after_unsub.status_code in [400, 404], \\\n                f\"Unexpected status code after unsubscribe: {resp_send_after_unsub.status_code}\"\n\n    except requests.RequestException as e:\n        assert False, f\"HTTP request failed: {e}\"\n\ntest_push_notifications_subscription_and_sending()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 89, in <module>\n  File \"<string>\", line 32, in test_push_notifications_subscription_and_sending\nAssertionError: Subscribe response status 500, body: {\"error\":\"Database table push_subscriptions does not exist. Please run database migrations.\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-19T19:00:46.499Z",
    "modified": "2026-01-19T19:03:18.761Z"
  }
]
